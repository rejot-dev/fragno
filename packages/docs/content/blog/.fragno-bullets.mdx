---
title: "Fragno"
description: ""
date: "2025-09-24"
author: "Wilco Kruijer"
---

## Libraries are not sufficient

- Traditional libraries integrate on _either_ the front-end _or_ the back-end, the library user is
  responsible for the glue-code.
- There are many cases where this is not sufficient.
- When the domain is split between front-end and back-end, there's a lot of re-implementation needed
  per project.
- For example:
  - AI/LLM Chat: user-interaction is key on the front-end, but also requires a back-end component to
    handle API keys and function calling.
  - Authentication: login forms, redirects on the front-end, back-end for verification and retrieval
    of data from third-party providers.
- Another area where traditional libraries are not sufficient is when there is a lot of integration
  between back-end services.
- For example:
  - Payments: receiving updates from the payment provider is key to follow the customer lifecycle.
  - Email: send emails, track bounces, open rates
- AI "Deep Research" is an example that has both. Front-end interaction to set up the research,
  back-end integration for function calls and webhooks for updates from the LLM provider.
- Even "pure" back-end libraries that don't really need any front-end work can be improved by having
  a more full-stack mindset. Imagine an API-first/API-only company that only provides one route that
  verifies if a person's name corresponds to a bank-account number. Presumably this would be
  integrated in some flow involving the user. A case is bound to come up where someone on the
  support staff wants to verify the result of this check. To do that we would need an engineer to
  create an API route on the internal back-end service, then a page on the front-end to display the
  result. If the library was full-stack, the API provider could simply provide a front-end function
  `verifyNameToBankAccount` that would call the internal back-end and forward to the provider. In
  this example, we're moving integration work from the library user, to the library author.

## Back-end

- If we can take away only one thing from the problem statement above: libraries need to be able to
  define API routes.
- Of course there are a million ways to define API routes. Depending on programming language and
  framework.
- In the Javascript world, we have full-stack frameworks like Next.js, React Router/Remix, Nuxt,
  SvelteKit, SolidStart, etc. There are also server-side frameworks like Astro, Express, and Hono.
- The common denominator is of course that they're all interfaces to HTTP, so an abstraction is
  definitely possible.
- A couple of lines of code in the user's codebase should be our goal to integrate.

## Front-end

- Front-ends have also standardized on some key abstractions. A big part of it is reactivity:
  re-render the UI when data changes. All major frameworks use this primitive (in their own way):
  React, Vue, Svelte, Solid, etc.
- How to handle data fetching is a bit more diverse, but these days most developers prefer "TanSack
  Query-style" fetching. A way to declaratively define data fetching logic, with automatic caching,
  re-fetching and invalidation based on a key.
- There are of course other ways such as RPC calls or GraphQL. Focusing on the simplest and most
  popular approach seems to be the best way to go.
- It's also important to think about the actual UI. UIs also have a very generic aspect, most
  dashboards have similar characteristics. Public and internal component libraries help with code
  re-use. In the end a bunch of tweaking local to the application is needed. ShadCN probably is the
  most well-known component library, and even has a pluggable registry of components.

## This is still not sufficient

- What would the requirements for integration with the data stack be?
- Querying:
  - For querying, we'd need some basics like: insert/insertMany, select, update, delete,
    exists/count. The question is how complex the query language should get. A typical relational
    database supports queries that are infeasible to support in a Framework-agnostic way. Even
    compiling/transpiling a sql-based 'generic' language is problematic when there are different
    targets such as Postgres, MySQL, SQLite, etc.
  - Certainly when we involve other database systems such as MongoDB, the differences are huge.
  - It has been shown that relational database systems can be implemented on top of key-value
    stores. My favourite example is the "Record Layer" built on top of FoundationDB. The fact that
    they're building an SQL engine on top thereof [^20] shows us that the key-value abstraction is
    powerful enough to support a wide range of use cases.
  - In essence this means that we'd only need `get`, `set`, `list`, `delete` operations. In a
    relational database this could be supported by having a single `kv` table. The ergonomics of
    this might be doubtful.
  - A simple query language, _without_ common-table expressions, sub-queries, and windowing might be
    sufficient. After all, the language should be able to get the job done for a library that wants
    to store data. Complexer queries might be better handled by the application author.

[^20]:
    FoundationDB,
    [Record Layer SQL Reference](https://foundationdb.github.io/fdb-record-layer/SQL_Reference.html)

- Schema Definition:
  - Using a single table key-value schema means we could sidestep the need for a schema definition
    entirely.
  - This would mean setting aside a lot of the benefits of relational databases, which most users
    that would integrate a full-stack library are using.
  - A basic schema definition DSL with simple types, supported by major databases could be useful.
  - Rudimentary references and relationships could be supported.
  - Indexes should be supported.
  - The main problem to be solved is how schemas defined in libraries would make their way to the
    user's application database schema.
  - We could generate migrations from our schema changes, and direct the user to run them.
  - If the user is using an ORM, it'd be harder to integrate with.

- Last point of attention would be transactions. Not all systems support interactive transactions.
- It could be worthwhile to take 'batched operations' as a lowest-common denominator. This, together
  with some optimistic concurrency control, could be a good way to handle data integrity.
