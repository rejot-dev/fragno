---
title: "Fragno"
description: ""
date: "2025-09-24"
author: "Wilco Kruijer"
---

## Libraries are not sufficient

Traditional libraries typically integrate on _either_ the front-end _or_ the back-end, leaving the
library user responsible for the glue code. That often isn't enough. When a domain spans both sides,
every project ends up re-implementing the same logic.

Take AI/LLM chat. The front-end owns the user interaction, while the back-end holds API keys and
handles function calling. Or take authentication: the front-end needs login forms and redirects; the
back-end verifies and retrieves data from third-party providers.

There’s also the world of back-end integrations. Payments depend on receiving updates from the
provider to follow the customer lifecycle. Email systems need to send messages and track bounces and
open rates.

AI "Deep Research" brings both sides together: the front-end sets up the research, and the back-end
integrates function calls and handles webhooks for updates from the LLM provider.

Even "pure" back-end libraries benefit from a full-stack mindset. Imagine an API-first, API-only
company that exposes a single route to check whether a person’s name matches a bank-account number.
In practice, someone on support will want to verify a result. Today, an engineer would create an
internal API route and a front-end page to display it. If the library were full-stack, the provider
could offer a front-end function `verifyNameToBankAccount` that calls the internal back end and
forwards to the provider. In this example, the integration work moves from the library user to the
library author.

## Back-end

If there’s one takeaway from the problem above, it’s this: libraries need to be able to define API
routes.

Of course, there are many ways to define API routes, depending on the programming language and
framework. In the JavaScript world we have full-stack frameworks like Next.js, React Router/Remix,
Nuxt, SvelteKit, and SolidStart, and we also have server-side frameworks like Astro, Express, and
Hono.

The common denominator is HTTP, so an abstraction is absolutely possible. The goal should be
integration in just a couple of lines of code in the user’s codebase.

## Front-end

Front-ends have also standardized on key abstractions. A big one is reactivity: re-render the UI
when data changes. All major frameworks use this primitive (in their own way): React, Vue, Svelte,
Solid.

Data fetching is more diverse, but these days most developers prefer a TanStack Query-style
approach: declaratively define fetching logic with automatic caching, re-fetching, and invalidation
based on a key. There are, of course, other ways such as RPC calls or GraphQL. Focusing on the
simplest and most popular approach tends to work best.

It’s also important to think about the UI itself. UIs have a very generic aspect; most dashboards
share similar characteristics. Public and internal component libraries help with code re-use. In the
end, a bunch of tweaking local to the application is still needed. ShadCN is a well-known component
library, and even has a pluggable registry of components.
