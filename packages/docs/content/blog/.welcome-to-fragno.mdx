---
title: "Fragno: Libraries should be full-stack and framework-agnostic"
description: ""
date: "2025-09-24"
author: "Wilco Kruijer"
---

## TL;DR

- **Libraries should ship both the server and the client**: one cohesive unit, not two
  half-libraries.
- **Frameworks are adapters, not foundations**: target the web platform, wrap for
  Next/Nuxt/SvelteKit/etc.
- **Fragments** are that unit in Fragno: server routes + reactive client, end‑to‑end typed,
  framework‑agnostic.
- **Users integrate in minutes**: mount one handler, import one client, get reactive
  hooks/composables.

---

## Libraries should be full‑stack and framework‑agnostic

Most “full‑stack” libraries still ship one side and ask users to write glue. That’s backwards. Your
API knows the data contracts and the client ergonomics better than your users do, so ship both.

Fragno treats frameworks as delivery mechanisms. The foundation is the web platform
(Request/Response, fetch, streaming). We wrap that for Next.js, Nuxt, SvelteKit, Astro, Express,
Hono, plain Node—thin adapters, zero framework lock‑in.

I call these libraries Fragments.

## What’s a Fragment?

A Fragment is a full‑stack library that:

- **Embeds** a server API into the user’s app (no separate service to deploy)
- **Exports** a reactive client for any UI framework (React/Vue/Svelte/Vanilla)
- **Keeps types intact** from route definitions to consumer code

The result: your users import a library, not a pile of recipes.

## The user experience (minimal, consistent)

Two steps and you’re done:

1. Mount the API once.

```ts
// Next.js
import { toNextJsHandler } from "@fragno-dev/core/next-js";
import { createExampleFragment } from "@fragno-dev/example-fragment";

const fragment = createExampleFragment({ someApiKey: process.env.EXAMPLE_API_KEY! });
export const { GET, POST, PUT, PATCH, DELETE } = toNextJsHandler(fragment);
```

2. Create the client and use it anywhere.

```ts
// React
import { createExampleFragmentClient } from "@fragno-dev/example-fragment/react";

const example = createExampleFragmentClient();

export function Todos() {
  const { data, loading, error } = example.useTodos({ query: { done: false } });
  if (loading) return <div>Loading…</div>;
  if (error) return <div>Oops</div>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

Same idea for Vue, Svelte, and Vanilla. If you mount the backend on a different path, pass
`mountRoute` to the client. That’s it.

## The author experience (own the client, not just the API)

Define routes once, get a reactive client for free. Under the hood Fragno uses Nanostores—small,
framework‑friendly signals—to power hooks/composables with TanStack Query‑style ergonomics.

```ts
import { defineFragment, defineRoute, createFragment } from "@fragno-dev/core";
import { createClientBuilder } from "@fragno-dev/core/client";

const todos = defineFragment<{ onTodoCreated?: (todo: Todo) => void }>("todos");

const getTodos = defineRoute({
  method: "GET",
  path: "/todos",
  outputSchema: TodoSchema,
  handler: async ({ query }, { json }) => json([]),
});

export function createTodos(config: { onTodoCreated?: (todo: Todo) => void }) {
  return createFragment(todos, config, [getTodos]);
}

export function createTodosClient() {
  const cb = createClientBuilder(todos, {}, [getTodos]);
  return {
    useTodos: cb.createHook("/todos"),
    // Mutations: cb.createMutator("POST", "/todos")
  } as const;
}
```

### Config, Dependencies, Services

- **Config** is the contract with your user: API keys, options, and callbacks.
- **Dependencies** are server‑only objects you construct from config (DB/SDK clients, etc.).
- **Services** are server‑only functions you choose to expose publicly alongside routes.

Keep the core generic. If you need framework‑specific niceties, do them in thin adapters.

## Reactive by default: hooks, mutators, and streaming

- `createHook` gives you read queries that react to parameter changes automatically.
- `createMutator` gives you mutations with invalidation baked in.
- Streaming is first‑class. When a route streams an array, the client updates live as chunks arrive.

You can also compose custom stores (derived data, combined states) and expose a single ergonomic
hook to users. You own the UX, not your consumers.

## Web standards first, then adapters

Everything speaks the platform: Web `Request`/`Response`, standard streaming, fetch semantics.
That’s why adapters stay tiny and consistent:

- Next.js, Nuxt, SvelteKit, Astro: file‑based route wrappers
- Express/Hono/Node: route mounts around the same web handler

No hidden framework magic, no re‑implementation per target.

## Why this matters

- **Shipping speed**: implement once, reach every stack your users are on.
- **User happiness**: zero glue code, predictable DX.
- **Type safety**: definitions flow from server to client without hand wiring.
- **Portability**: frameworks change; web standards don’t.

## Try it

1. Install a fragment, mount its handler.
2. Create the client for your UI framework.
3. Call a hook/composable and ship.

If you’re authoring a library today, make it a Fragment. Own the full stack. Treat frameworks as
adapters. And make your users smile when integration takes minutes—not days.
