---
title: "Full-stack mindset for libraries with Fragno"
description: ""
date: "2025-09-29"
author: "Wilco Kruijer"
---

## Libraries are _not_ sufficient

Traditional libraries are usually built to integrate on _either_ the front-end _or_ the back-end,
leaving the library implementer responsible for the glue code. Many, if not most, domains span both
sides. Libraries take away some of the implementation burden, but this is not enough. Every project
demands the re-implementation and custom wiring of the library.

Take an AI/LLM chatbot: on the front-end, the user interaction is the heart of the experience, while
the back-end holds API keys and handles function calling. If we look at the `openai` library, it
only provides the back-end functionality. The user is responsible for defining routes and handling
communication. Function calling requires code on both sides, you'd probably also want to support
streaming responses. This all is to be implemented by the user.

This is an example of a domain where most glue is in the communication between the front-end and the
back-end. There's also webhooks, a form of integration between back-end services. Libraries
typically provide helpers, but not much else.

Some examples of domains that could use deeper integration are:

- **Authentication**: the front-end needs login forms and redirects; the back-end verifies and
  retrieves data from third-party providers.
- **Payments**: receiving updates from the payment provider is key to follow the customer lifecycle.
- **Email**: send emails, track bounces, and open rates.

When extending the AI example to include _"Deep Research"_ we see that glue code on all sides comes
into play: the front-end sets up the research, and the back-end integrates function calls and
handles webhooks for updates from the LLM provider.

Imagine a code base after adding deep research functionality to your back office dashboard. **It's
all over the place.** Integration points are everywhere and it's easy to lose track. How many files
are you touching when migrating from the `completions` to `responses` API? [^10]

[^10]:
    The `completions` API is the original OpenAI API to interface with their LLMs. This has since
    been superseded by the `responses` API. See
    [Migrate to the Responses API](https://platform.openai.com/docs/guides/migrate-to-responses).

And it's not limited to the front-end/back-end divide. Let's say we're integrating with a company
called "IBAN Check, EU-Inc.", They expose a single route to check whether a person's name matches a
bank-account number:

```json title="POST /api/verify" tab="Request"
{
  "name": "Wilco Kruijer",
  "bankAccountNumber": "NL99BANK1234123400"
}
```

```json title="POST /api/verify" tab="Response"
{
  "status": "valid"
}
```

Presumably, in the initial implementation this API is only called in some KYC background process.
However, a case is bound to come up where a verification has failed and someone in the support team
wants to verify the result. We have to get out the glue (code) again.

It would have been great if the company had the ability to define internal API routes and a
front-end function to go with it.

## How to make this better?

So how do we go about solving this?

### Back-end

If there's only one takeaway from the earlier problem statement, it's this: **libraries need to be
able to define API routes.**

Of course, that's easier said than done. There are a great many ways to define API routes, depending
on the programming language and framework you're working with. In the JavaScript world, we have
full-stack frameworks like Next.js, React Router/Remix, Nuxt, SvelteKit, and SolidStart. On the more
server-focused side, there are frameworks such as Astro, Express, and Hono.

The common denominator is obvious: they're all interfaces to HTTP. The modern frameworks have
standardized on the `Request` and `Response` objects, so an abstraction is definitely possible.

The goal should be simplicity. The library user should only need to write a couple of lines of code
in their own codebase to start using a library. Anything more, and we're back to pushing complexity
onto the user instead of the library.

### Front-end

On the front-end side, there's also standardization around a few key abstractions. The most
important one is reactivity: re-rendering the UI whenever data changes. Every major modern framework
builds on this primitive, even if the implementations differ. React, Vue, Svelte, Solid, etc.

Data fetching is more diverse, but these days most developers prefer a TanStack Query-style
approach. With it, you can declaratively define data-fetching logic with automatic caching,
re-fetching, and invalidation based on a key.

There are other approaches too, like RPC calls or GraphQL. But the simplest and most widely adopted
option is the TanStack Query-style approach.

And then there's the UI itself. As an example, take a dashboard. Most dashboards share similar
characteristics. Public and internal component libraries exist to capitalize on the common ground.
ShadCN is probably the most well-known component library. It even has a pluggable registry of
components that can already be used cross-project boundaries.

## Idea: full-stack libraries

As discussed, many of the popular frameworks in the JavaScript ecosystem are "full-stack"
frameworks. They allow the user to write both the server-side and client-side functionality in the
same codebase. **Libraries have not caught up to this.**

For this reason, I'm building **Fragno**, a <ins>fr</ins>amework-<ins>agno</ins>stic toolkit for
building full-stack libraries that adheres to the ideas discussed in this article. The name
symbolizes the idea that libraries written with Fragno should work with any framework.

The core idea is that a library author defines not only functionality as libraries already do, but
also HTTP-routes and a client-side interface. These routes are then embedded into the user's
application, by mounting them on a specific path in the application.

## What users see

### Integration points

The integration points the user has to deal with should be as minimal as possible. Only a couple
lines of code, max.

**Back-end**

The following code snippets show how a user would integrate a Fragno library into their application.
As you can see, a bunch of frameworks are already supported.

<include>../.includes/blog/fragno-introduction/users-back-end.md</include>

**Front-end**

Like the back-end component, it only takes a few lines of code to integrate. The `useFragno`
function is framework-specific, and accommodates the reactivity of the framework.

<include>../.includes/blog/fragno-introduction/users-front-end.md</include>

### Usage

To start using a Fragno library, the user simply imports the object created in a central position
(see above). It then looks very similar to TanStack Query's `useQuery` hook.

```tsx title="components/ExampleComponent.tsx"
import { exampleFragment } from "@/lib/example-fragment-client";

const { useTodos } = exampleFragment;

export function MyComponent() {
  const { data, loading, error } = useTodos();

  return (
    <div>
      <h1>Example Component</h1>
      {loading ? <div>Loading...</div> : <div>{data}</div>}
    </div>
  );
}
```

## Creating full-stack libraries

So what does it take to build a full-stack library? On the server side, it looks a lot like any
other web routing framework. Take the following route definition that is part of the hypothetical
`example-fragment` library:

```typescript title="routes/get-todos.ts"
import { defineRoute } from "@fragno-dev/core";
import { z } from "zod";

export const getTodosRoute = defineRoute({
  method: "GET",
  path: "/todos",
  outputSchema: z.array(/* TodoSchema */),
  handler: async (_, { json }) => {
    return json([
      {
        id: "1",
        text: "Learn Fragno",
        done: false,
        createdAt: new Date().toISOString(),
      },
    ]);
  },
});
```

This handler would be invoked when a HTTP GET request is made to `/api/example-fragment/todos`
(unless the implementing user explicitly mounts the route on a different path).

In this case, the route is clearly meant to be called from the client-side. We could also define
routes that could be called by external services, like a webhook.

To facilitate calling this route from the client-side, we need to build the client object for the
example library. This would look something like this:

```typescript title="src/index.ts"
import { getTodosRoute } from "./routes/get-todos";
import { addTodoRoute } from "./routes/post-todos";

import { createClientBuilder } from "@fragno-dev/core/client";
import type { FragnoPublicClientConfig } from "@fragno-dev/core";

export function createExampleFragmentClient(fragnoConfig: FragnoPublicClientConfig = {}) {
  const cb = createClientBuilder(todosDefinition, fragnoConfig, [getTodosRoute, addTodoRoute]);
  return {
    useTodos: cb.createHook("/todos"),
    useAddTodo: cb.createMutator("POST", "/todos"),
  };
}
```

## Under the hood

A bunch of things had to happen behind the scenes to make this all work.

### Client-side state management

Under the hood, Fragno uses [Nano Stores](https://github.com/nanostores/nanostores) and
[Nano Stores Query](https://github.com/nanostores/query) to create fully reactive client-side data
fetchers. This means that caching, re-fetching, and invalidation are all handled out of the box.

For library authors, this means that Nano Store's primitives like `computed` can be used to operate
on these stores. The client experience is completely customizable, you don't have to use the
`createHook` and `createMutator` methods at all.

On the user's side, these stores are converted to the framework-specific reactive primitive. For
example, in Vue this means that `ref`s can be passed to hooks as path or query parameters to
automatically re-fetch the hook when the `ref` changes. It also means that composables can be
created by the user to further customize their usage of the library.

### Type safety & Code splitting

Every Fragno library has a single canonical definition. This definition is used to create both the
server and client objects. Hooks created with the client builder methods are fully type-safe,
meaning that the `data` returned by the `useTodos` hook is guaranteed to be an array of `Todo`
objects. Fragno schemas accept schemas that are compatible with
[Standard Schema](https://standardschema.dev/).

A problem with this setup is that the single object contains code that should only be executed on
the server (the route handlers). All full-stack frameworks solve this by code-splitting, and so does
Fragno. `@fragno-dev/unplugin-fragno` is a plugin that automatically splits the code between client
and server bundles. This build step is only required for library authors, not for end-users.

### Other features

There are a bunch of other features that make Fragno a complete full-stack toolkit.

- **Streaming support**: streaming responses are supported, first-class.
- **Middleware support**: users can define middleware that run in front of route handlers defined by
  a library. This lets the user make sure that requests are properly authenticated, rate-limited,
  etc.
- **Dependencies & Services**: dependencies can be used to create library-private objects that can
  be used in route handlers. Services are functions that are available to the user in the
  server-side context. This lets the library author expose functionality to the user that they can
  in turn use to do things like background processing.

## This is still not sufficient

In this article, I've glossed over a very important thing: **data**. A library cannot truly be
full-stack if it doesn't handle data storage. In the use case of receiving webhooks, it's clear that
the library needs to be able to interact with a database.

### Querying

Let's start with querying. At the very least, a useful abstraction would need basic operations:

- insert / insertMany
- select
- update
- delete
- exists / count

The tricky part is deciding how far to take the query language. A typical relational database
supports queries that are infeasible to support in a Framework-agnostic way. Trying to compile or
transpile a generic SQL dialect is problematic when your targets include Postgres, MySQL, SQLite,
and so on. And once you bring in systems like MongoDB, the differences only get larger.

That said, we know relational systems can be built on top of much simpler abstractions. My favorite
example is the _Record Layer_ built on FoundationDB, which essentially builds a full SQL engine on
top of a key-value store [^20]. The fact that this works at all shows how powerful the simple
key-value abstraction really is.

[^20]:
    FoundationDB,
    [Record Layer SQL Reference](https://foundationdb.github.io/fdb-record-layer/SQL_Reference.html)

In the essence, this suggests that a minimal set of operations: `get`, `set`, `list`, `delete` could
be enough. In a relational database, you could even implement these with a single `kv` table. The
ergonomics may leave something to be desired, but it gets the job done.

A simple query language, _without_ common-table expressions, sub-queries, and windowing might be
sufficient. After all, the language should be able to get the job done for a library that wants to
store data. Complexer queries might be better handled by the application author.

### Schema Definition

If we go with a single key-value table, then schema definition can be sidestepped entirely. This
would mean setting aside a lot of the benefits of relational databases, that most developers
integrating full-stack libraries are accustomed to.

A middle ground might be to offer a basic schema definition DSL with simple types, supported across
the major databases. Add in rudimentary references and relationships, plus support for indexes, and
you cover most common cases.

The real challenge isn't defining schemas, but syncing them. How do schemas defined in a library
make their way into the user's application database? One option is generating migrations from schema
changes and having the user run them. But if the application is using an ORM, the integration story
becomes much more complicated. Right now, I'm not sure how to handle this properly.

### Transactions

Finally, there's the question of transactions. Not all systems support interactive transactions,
which makes it hard to rely on them as a common denominator. Even if all systems did support
interactive transactions, I would be weary of letting a dependency hog a database connection.

A more practical approach might be to treat batched operations as the common ground, and combine
that with optimistic concurrency control [^30]. Together, these techniques could provide a workable
baseline for maintaining data integrity without demanding too much from the underlying system.

[^30]:
    With optimistic concurrency control (OCC), we could retrieve a value outside of a transaction,
    and then update it later with the restriction that the value has not changed since it was
    retrieved.

## Conclusion

Fragno is an attempt to bring the full-stack mindset to libraries: ship routes, a client, and a
tiny, framework-agnostic integration surface. The first iteration is now available, completely free
and open-source. The data story still requires some input and experimentation. Any opinions are more
than welcome!

If you want to learn more about Fragno:

- Read the [User Quick Start](/docs/user-quick-start)
- Read the [Library Quick Start](/docs/for-library-authors/getting-started)

And please give our [GitHub Repository](https://github.com/fragno-dev/fragno) a star!
