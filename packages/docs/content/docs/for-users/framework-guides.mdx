---
title: Framework-Specific Guides
description: Detailed guides for integrating Fragno with specific frameworks
---

# Framework-Specific Guides

This page provides detailed integration guides for each supported framework.

## React

### Next.js 14+ (App Router)

#### Server Setup

Create a catch-all API route to handle your fragment:

```typescript title="app/api/my-fragment/[...all]/route.ts"
import { createMyFragment } from "@my-org/my-fragment";
import { toNextJsHandler } from "@fragno-dev/core/next-js";

const fragment = createMyFragment({
  // Your fragment configuration
  apiKey: process.env.API_KEY!,
});

export const { GET, POST, PUT, PATCH, DELETE } = toNextJsHandler(fragment);
```

#### Client Setup

```typescript title="lib/fragment-client.ts"
import { createMyFragmentClient } from "@my-org/my-fragment";

export const myFragmentClient = createMyFragmentClient({
  baseUrl: process.env.NEXT_PUBLIC_BASE_URL || "",
  mountRoute: "/api/my-fragment",
});
```

#### Usage in Components

```typescript title="components/MyComponent.tsx"
"use client";

import { useFragno } from "@fragno-dev/core/react";
import { myFragmentClient } from "@/lib/fragment-client";

const { useData, useCreateItem } = useFragno(myFragmentClient);

export default function MyComponent() {
  const { data, loading, error, refetch } = useData();
  const { mutate: createItem, loading: creating } = useCreateItem();

  // Component logic here
}
```

#### Environment Variables

```bash title=".env.local"
API_KEY=your_api_key_here
NEXT_PUBLIC_BASE_URL=http://localhost:3000
```

### Next.js 13 (Pages Router)

#### API Route

```typescript title="pages/api/my-fragment/[...all].ts"
import type { NextApiRequest, NextApiResponse } from "next";
import { createMyFragment } from "@my-org/my-fragment";

const fragment = createMyFragment({
  apiKey: process.env.API_KEY!,
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const request = new Request(`http://localhost${req.url}`, {
    method: req.method,
    headers: req.headers as any,
    body: req.method !== "GET" ? JSON.stringify(req.body) : undefined,
  });

  const response = await fragment.handler(request);
  const data = await response.json();

  res.status(response.status).json(data);
}
```

### Create React App / Vite

#### Development Proxy

Add a proxy to your `vite.config.ts` or `package.json`:

```typescript title="vite.config.ts"
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": "http://localhost:3001", // Your backend server
    },
  },
});
```

#### Client Setup

```typescript title="src/lib/client.ts"
import { createMyFragmentClient } from "@my-org/my-fragment";

export const client = createMyFragmentClient({
  baseUrl: import.meta.env.VITE_API_URL || "http://localhost:3000",
  mountRoute: "/api/my-fragment",
});
```

## Vue

### Nuxt 3

#### Server Setup

```typescript title="server/api/my-fragment/[...all].ts"
import { createMyFragment } from "@my-org/my-fragment";

const fragment = createMyFragment({
  apiKey: useRuntimeConfig().apiKey,
});

export default defineEventHandler(async (event) => {
  const request = new Request(getRequestURL(event), {
    method: event.method,
    headers: getHeaders(event),
    body: event.method !== "GET" ? await readBody(event) : undefined,
  });

  return await fragment.handler(request);
});
```

#### Runtime Configuration

```typescript title="nuxt.config.ts"
export default defineNuxtConfig({
  runtimeConfig: {
    apiKey: process.env.API_KEY,
    public: {
      baseUrl: process.env.NUXT_PUBLIC_BASE_URL || "http://localhost:3000",
    },
  },
});
```

#### Client Plugin

```typescript title="plugins/fragment.client.ts"
import { createMyFragmentClient } from "@my-org/my-fragment";

export default defineNuxtPlugin(() => {
  const { $config } = useNuxtApp();

  const client = createMyFragmentClient({
    baseUrl: $config.public.baseUrl,
    mountRoute: "/api/my-fragment",
  });

  return {
    provide: {
      fragmentClient: client,
    },
  };
});
```

#### Usage in Components

```vue title="components/MyComponent.vue"
<script setup>
import { useFragno } from "@fragno-dev/core/vue";

const { $fragmentClient } = useNuxtApp();
const { useData, useCreateItem } = useFragno($fragmentClient);

const data = useData();
const createItem = useCreateItem();
</script>
```

### Vue 3 + Vite

#### Client Setup

```typescript title="src/lib/client.ts"
import { createMyFragmentClient } from "@my-org/my-fragment";

export const client = createMyFragmentClient({
  baseUrl: import.meta.env.VITE_API_URL || "http://localhost:3000",
  mountRoute: "/api/my-fragment",
});
```

#### Usage

```vue title="src/components/MyComponent.vue"
<script setup lang="ts">
import { useFragno } from "@fragno-dev/core/vue";
import { client } from "@/lib/client";

const { useData, useCreateItem } = useFragno(client);

const data = useData();
const createItem = useCreateItem();
</script>
```

## Server Frameworks

### React Router v7 / Remix

#### Route Setup

```typescript title="app/routes/api.my-fragment.tsx"
import type { LoaderFunctionArgs, ActionFunctionArgs } from "@remix-run/node";
import { createMyFragment } from "@my-org/my-fragment";

const fragment = createMyFragment({
  apiKey: process.env.API_KEY!,
});

export async function loader({ request }: LoaderFunctionArgs) {
  return await fragment.handler(request);
}

export async function action({ request }: ActionFunctionArgs) {
  return await fragment.handler(request);
}
```

#### Client Usage

```typescript title="app/routes/_index.tsx"
import { useFragno } from "@fragno-dev/core/react";
import { createMyFragmentClient } from "@my-org/my-fragment";

const client = createMyFragmentClient({
  baseUrl: "", // Same origin
  mountRoute: "/api/my-fragment",
});

export default function Index() {
  const { useData } = useFragno(client);
  const { data, loading } = useData();

  return <div>{/* Your component */}</div>;
}
```

### Express.js

#### Server Setup

```typescript title="server.js"
import express from "express";
import { toNodeHandler } from "@fragno-dev/core/node";
import { createMyFragment } from "@my-org/my-fragment";

const app = express();

const fragment = createMyFragment({
  apiKey: process.env.API_KEY,
});

// Convert to Express middleware
app.use("/api/my-fragment", toNodeHandler(fragment));

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

#### CORS Setup

```typescript title="server.js"
import express from "express";
import cors from "cors";
import { toNodeHandler } from "@fragno-dev/core/node";
import { createMyFragment } from "@my-org/my-fragment";

const app = express();

// Enable CORS for your frontend
app.use(
  cors({
    origin: "http://localhost:5173", // Your frontend URL
    credentials: true,
  }),
);

const fragment = createMyFragment({
  apiKey: process.env.API_KEY,
});

app.use("/api/my-fragment", toNodeHandler(fragment));
```

### Astro

#### API Route

```typescript title="src/pages/api/my-fragment/[...all].ts"
import type { APIRoute } from "astro";
import { createMyFragment } from "@my-org/my-fragment";

const fragment = createMyFragment({
  apiKey: import.meta.env.API_KEY,
});

export const ALL: APIRoute = async ({ request }) => {
  return await fragment.handler(request);
};
```

#### Client Usage

```astro title="src/components/MyComponent.astro"
---
// Server-side code
---

<div id="my-component"></div>

<script>
  import { createMyFragmentClient } from "@my-org/my-fragment";

  const client = createMyFragmentClient({
    baseUrl: window.location.origin,
    mountRoute: "/api/my-fragment",
  });

  // Use with vanilla JS or integrate with your preferred frontend framework
</script>
```

### Fastify

#### Server Setup

```typescript title="server.ts"
import Fastify from "fastify";
import { createMyFragment } from "@my-org/my-fragment";

const fastify = Fastify();

const fragment = createMyFragment({
  apiKey: process.env.API_KEY!,
});

// Register fragment handler for all methods
fastify.all("/api/my-fragment/*", async (request, reply) => {
  const webRequest = new Request(`http://localhost${request.url}`, {
    method: request.method,
    headers: request.headers as any,
    body: request.method !== "GET" ? JSON.stringify(request.body) : undefined,
  });

  const response = await fragment.handler(webRequest);
  const data = await response.text();

  reply.status(response.status).headers(Object.fromEntries(response.headers.entries())).send(data);
});

fastify.listen({ port: 3000 });
```

## Deployment Platforms

### Vercel

#### Configuration

```json title="vercel.json"
{
  "functions": {
    "app/api/my-fragment/[...all]/route.ts": {
      "maxDuration": 30
    }
  },
  "env": {
    "API_KEY": "@api-key"
  }
}
```

#### Environment Variables

Set environment variables in the Vercel dashboard or via CLI:

```bash
vercel env add API_KEY production
```

### Netlify

#### Functions Setup

```typescript title="netlify/functions/my-fragment.ts"
import type { Handler } from "@netlify/functions";
import { createMyFragment } from "@my-org/my-fragment";

const fragment = createMyFragment({
  apiKey: process.env.API_KEY!,
});

export const handler: Handler = async (event, context) => {
  const request = new Request(`https://${event.headers.host}${event.path}`, {
    method: event.httpMethod,
    headers: event.headers,
    body: event.body,
  });

  const response = await fragment.handler(request);

  return {
    statusCode: response.status,
    headers: Object.fromEntries(response.headers.entries()),
    body: await response.text(),
  };
};
```

#### Redirects

```toml title="netlify.toml"
[[redirects]]
  from = "/api/my-fragment/*"
  to = "/.netlify/functions/my-fragment"
  status = 200
```

### Railway

#### Dockerfile

```dockerfile title="Dockerfile"
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

#### Railway Configuration

```json title="railway.json"
{
  "build": {
    "builder": "dockerfile"
  },
  "deploy": {
    "startCommand": "npm start"
  }
}
```

## Development Tips

### Hot Reload

Most frameworks support hot reload out of the box. For custom setups:

```typescript
if (process.env.NODE_ENV === "development") {
  // Enable development mode features
  fragment.enableHotReload();
}
```

### Debugging

Enable debug logging:

```typescript
const fragment = createMyFragment(
  {
    apiKey: process.env.API_KEY!,
  },
  {
    debug: process.env.NODE_ENV === "development",
  },
);
```

### CORS in Development

For local development across different ports:

```typescript
const fragment = createMyFragment(config, {
  cors: {
    origin: "http://localhost:5173", // Your frontend dev server
    credentials: true,
  },
});
```

### Error Handling

Add global error boundaries:

```typescript title="React Error Boundary"
import React from "react";

class FragnoErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Fragment error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>Something went wrong with the fragment.</div>;
    }

    return this.props.children;
  }
}
```

## Performance Optimization

### Bundle Size

Use dynamic imports for client code:

```typescript
// Lazy load the fragment client
const loadClient = async () => {
  const { createMyFragmentClient } = await import("@my-org/my-fragment");
  return createMyFragmentClient(config);
};
```

### Caching

Configure caching headers:

```typescript
const fragment = createMyFragment(config, {
  cache: {
    maxAge: 3600, // 1 hour
    staleWhileRevalidate: 86400, // 24 hours
  },
});
```

### Code Splitting

Ensure you're using the unplugin for automatic code splitting:

```typescript title="vite.config.ts"
import { defineConfig } from "vite";
import fragno from "@fragno-dev/unplugin-fragno/vite";

export default defineConfig({
  plugins: [fragno()],
});
```

This ensures server-side code never reaches client bundles.

## Troubleshooting

### Common Issues

1. **CORS errors**: Configure CORS in your fragment configuration
2. **TypeScript errors**: Ensure you're importing types correctly
3. **Bundle size issues**: Use the unplugin for code splitting
4. **Hot reload not working**: Check your framework's development setup

### Getting Help

- Check the [API Reference](/docs/api-reference) for detailed function signatures
- See [Examples](/docs/examples) for working code samples
- Report issues on [GitHub](https://github.com/anthropics/fragno/issues)
