---
title: Best Practices
description: Best practices and conventions for building Fragno fragments
---

# Best Practices

Follow these best practices when building Fragno fragments to ensure they are robust, maintainable,
and user-friendly.

## API Design

### 1. Use Descriptive Names

Choose clear, descriptive names for your fragment and routes:

```typescript
// ✅ Good
const userManagementDefinition = defineFragment<UserConfig>("user-management");

const getUserRoute = defineRoute({
  method: "GET",
  path: "/users/:id",
  // ...
});

// ❌ Bad
const libDef = defineFragment<Config>("lib");

const route1 = defineRoute({
  method: "GET",
  path: "/u/:id",
  // ...
});
```

### 2. Follow RESTful Conventions

Use standard HTTP methods and URL patterns:

```typescript
// ✅ Good RESTful design
const routes = [
  // List resources
  defineRoute({ method: "GET", path: "/users" }),

  // Get specific resource
  defineRoute({ method: "GET", path: "/users/:id" }),

  // Create resource
  defineRoute({ method: "POST", path: "/users" }),

  // Update resource (full)
  defineRoute({ method: "PUT", path: "/users/:id" }),

  // Update resource (partial)
  defineRoute({ method: "PATCH", path: "/users/:id" }),

  // Delete resource
  defineRoute({ method: "DELETE", path: "/users/:id" }),
];
```

### 3. Use Proper HTTP Status Codes

Return appropriate status codes for different scenarios:

```typescript
const createUserRoute = defineRoute({
  method: "POST",
  path: "/users",
  handler: async ({ input }, { json, error }) => {
    const userData = await input.valid();

    // Check if user already exists
    const existingUser = await findUserByEmail(userData.email);
    if (existingUser) {
      return error(
        { message: "User already exists", code: "USER_EXISTS" },
        409, // Conflict
      );
    }

    try {
      const user = await createUser(userData);
      return json(user, { status: 201 }); // Created
    } catch (err) {
      return error(
        { message: "Failed to create user", code: "CREATION_FAILED" },
        500, // Internal Server Error
      );
    }
  },
});
```

## Schema Design

### 1. Use Strict Schemas

Define comprehensive schemas with proper validation:

```typescript
// ✅ Good - Strict schema with validation
const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  name: z.string().min(1).max(100),
  age: z.number().int().min(0).max(150),
  role: z.enum(["user", "admin", "moderator"]),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime().optional(),
});

// ❌ Bad - Loose schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string(),
  age: z.number(),
});
```

### 2. Use Consistent Naming

Follow consistent naming conventions across your schemas:

```typescript
// ✅ Good - Consistent camelCase
const UserSchema = z.object({
  id: z.string(),
  firstName: z.string(),
  lastName: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

const PostSchema = z.object({
  id: z.string(),
  title: z.string(),
  content: z.string(),
  authorId: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

// ❌ Bad - Inconsistent naming
const UserSchema = z.object({
  id: z.string(),
  first_name: z.string(), // snake_case
  lastName: z.string(), // camelCase
  created_at: z.string(), // snake_case
});
```

### 3. Use Optional Fields Appropriately

Mark fields as optional only when they truly are:

```typescript
const CreateUserSchema = z.object({
  email: z.string().email(),
  name: z.string(),
  // Optional fields for creation
  bio: z.string().optional(),
  avatar: z.string().url().optional(),
});

const UpdateUserSchema = z.object({
  // All fields optional for updates
  email: z.string().email().optional(),
  name: z.string().optional(),
  bio: z.string().optional(),
  avatar: z.string().url().optional(),
});
```

## Configuration Design

### 1. Provide Sensible Defaults

Make your fragment easy to use out of the box:

```typescript
export interface MyFragmentConfig {
  apiKey: string; // Required
  timeout?: number; // Optional with default
  retries?: number; // Optional with default
  debug?: boolean; // Optional with default
}

const myFragmentDefinition = defineFragment<MyFragmentConfig>("my-fragment").withDependencies(
  (config) => ({
    timeout: config.timeout ?? 5000, // 5 second default
    retries: config.retries ?? 3,
    debug: config.debug ?? false,
  }),
);
```

### 2. Use Type-Safe Configuration

Leverage TypeScript for better developer experience:

```typescript
export interface DatabaseConfig {
  type: "postgres" | "mysql" | "sqlite";
  host?: string;
  port?: number;
  database: string;
  // Use conditional types for type-specific options
  ssl?: DatabaseConfig["type"] extends "postgres" ? boolean : never;
}
```

### 3. Validate Configuration

Validate configuration at runtime:

```typescript
const configSchema = z.object({
  apiKey: z.string().min(1, "API key is required"),
  timeout: z.number().positive().default(5000),
  retries: z.number().int().min(0).max(10).default(3),
});

const myFragmentDefinition = defineFragment<MyFragmentConfig>("my-fragment").withDependencies(
  (config) => {
    // Validate config
    const validConfig = configSchema.parse(config);

    return {
      apiClient: new ApiClient(validConfig.apiKey),
      timeout: validConfig.timeout,
      retries: validConfig.retries,
    };
  },
);
```

## Error Handling

### 1. Define Custom Error Codes

Use meaningful error codes for better client handling:

```typescript
const errorCodes = [
  "UNAUTHORIZED",
  "FORBIDDEN",
  "NOT_FOUND",
  "VALIDATION_ERROR",
  "RATE_LIMITED",
  "EXTERNAL_API_ERROR",
] as const;

const myRoute = defineRoute({
  errorCodes,
  handler: async (_, { error }) => {
    // Type-safe error codes
    return error(
      {
        message: "Access denied",
        code: "FORBIDDEN",
        details: "User lacks required permissions",
      },
      403,
    );
  },
});
```

### 2. Provide Helpful Error Messages

Include context and suggestions in error messages:

```typescript
// ✅ Good - Helpful error message
return error(
  {
    message: "Invalid email format",
    code: "VALIDATION_ERROR",
    field: "email",
    provided: email,
    expected: "valid email address (e.g., user@example.com)",
  },
  400,
);

// ❌ Bad - Vague error message
return error({ message: "Bad request" }, 400);
```

### 3. Handle External API Errors

Wrap external API calls with proper error handling:

```typescript
const fetchDataRoute = defineRoute({
  errorCodes: ["EXTERNAL_API_ERROR", "TIMEOUT"] as const,
  handler: async ({ deps }, { json, error }) => {
    try {
      const response = await deps.externalApi.fetchData({
        timeout: deps.timeout,
      });

      return json(response);
    } catch (err) {
      if (err.code === "TIMEOUT") {
        return error(
          {
            message: "External API request timed out",
            code: "TIMEOUT",
            retryAfter: 60,
          },
          504,
        );
      }

      return error(
        {
          message: "Failed to fetch data from external API",
          code: "EXTERNAL_API_ERROR",
          originalError: err.message,
        },
        502,
      );
    }
  },
});
```

## Performance

### 1. Use Streaming for Large Responses

Stream data instead of loading everything into memory:

```typescript
// ✅ Good - Streaming large dataset
const getLargeDatasetRoute = defineRoute({
  method: "GET",
  path: "/large-dataset",
  handler: async (_, { jsonStream }) => {
    return jsonStream(async (stream) => {
      const batches = await loadDataInBatches();

      for (const batch of batches) {
        for (const item of batch) {
          await stream.write(item);
        }
        // Small delay to prevent overwhelming
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
    });
  },
});

// ❌ Bad - Loading everything into memory
const getBadDatasetRoute = defineRoute({
  method: "GET",
  path: "/bad-dataset",
  handler: async (_, { json }) => {
    const allData = await loadAllData(); // Potentially millions of records
    return json(allData); // Memory explosion
  },
});
```

### 2. Implement Pagination

Always paginate large collections:

```typescript
const listUsersRoute = defineRoute({
  method: "GET",
  path: "/users",
  querySchema: z.object({
    page: z.coerce.number().int().positive().default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
    sort: z.enum(["name", "email", "createdAt"]).default("createdAt"),
    order: z.enum(["asc", "desc"]).default("desc"),
  }),
  outputSchema: z.object({
    users: z.array(UserSchema),
    pagination: z.object({
      page: z.number(),
      limit: z.number(),
      total: z.number(),
      pages: z.number(),
      hasNext: z.boolean(),
      hasPrev: z.boolean(),
    }),
  }),
  handler: async ({ query }, { json }) => {
    const { page, limit, sort, order } = await query.valid();

    const offset = (page - 1) * limit;
    const { users, total } = await findUsers({
      limit,
      offset,
      sort,
      order,
    });

    return json({
      users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: offset + limit < total,
        hasPrev: page > 1,
      },
    });
  },
});
```

### 3. Use Proper Caching

Implement caching where appropriate:

```typescript
const getCachedDataRoute = defineRoute({
  method: "GET",
  path: "/cached-data/:id",
  pathSchema: z.object({ id: z.string() }),
  handler: async ({ path }, { json }) => {
    const { id } = await path.valid();

    const data = await getDataWithCache(id);

    return json(data, {
      headers: {
        "Cache-Control": "public, max-age=3600", // 1 hour cache
        ETag: generateETag(data),
      },
    });
  },
});
```

## Testing

### 1. Test Error Conditions

Don't just test the happy path:

```typescript
describe("User creation", () => {
  it("should create user successfully", async () => {
    // Happy path test
  });

  it("should reject duplicate email", async () => {
    // Error condition test
    const fragment = createUserFragment();

    // Create first user
    await fragment.handler(
      createRequest("POST", "/users", {
        email: "test@example.com",
        name: "Test User",
      }),
    );

    // Try to create duplicate
    const response = await fragment.handler(
      createRequest("POST", "/users", {
        email: "test@example.com",
        name: "Another User",
      }),
    );

    expect(response.status).toBe(409);
    const error = await response.json();
    expect(error.code).toBe("USER_EXISTS");
  });

  it("should validate required fields", async () => {
    // Validation test
    const response = await fragment.handler(
      createRequest("POST", "/users", {
        name: "Test User",
        // Missing email
      }),
    );

    expect(response.status).toBe(400);
  });
});
```

### 2. Test Configuration Validation

Test that invalid configurations are rejected:

```typescript
describe("Configuration validation", () => {
  it("should reject invalid API key", () => {
    expect(() => {
      createMyFragment({ apiKey: "" });
    }).toThrow("API key is required");
  });

  it("should use default timeout", () => {
    const fragment = createMyFragment({ apiKey: "valid-key" });
    expect(fragment.config.timeout).toBe(5000);
  });
});
```

## Documentation

### 1. Document Configuration Options

Provide clear documentation for all configuration options:

```typescript
export interface ChatFragmentConfig {
  /** OpenAI API key for AI completions */
  openaiApiKey: string;

  /**
   * AI model to use for completions
   * @default "gpt-3.5-turbo"
   */
  model?: string;

  /**
   * Maximum tokens in AI responses
   * @default 1000
   */
  maxTokens?: number;

  /**
   * System prompt for AI behavior
   * @default "You are a helpful assistant."
   */
  systemPrompt?: string;

  /**
   * Called when a conversation is created
   * @param conversation - The created conversation
   */
  onConversationCreated?: (conversation: Conversation) => void;
}
```

### 2. Provide Usage Examples

Include practical examples in your documentation:

````typescript
/**
 * # Todo Fragment
 *
 * A simple todo management fragment.
 *
 * ## Usage
 *
 * ### Server Setup (Next.js)
 * ```typescript
 * // app/api/todos/[...all]/route.ts
 * import { createTodos } from "@my-org/todo-fragment";
 * import { toNextJsHandler } from "@fragno-dev/core/next-js";
 *
 * const todos = createTodos({
 *   maxTodos: 100,
 *   onTodoCreated: (todo) => console.log("Created:", todo.text),
 * });
 *
 * export const { GET, POST, PUT, DELETE } = toNextJsHandler(todos);
 * ```
 *
 * ### Client Usage (React)
 * ```typescript
 * const client = createTodosClient({ baseUrl: "http://localhost:3000" });
 * const { useTodos, useCreateTodo } = useFragno(client);
 *
 * function TodoApp() {
 *   const { data: todos, loading } = useTodos();
 *   const { mutate: createTodo } = useCreateTodo();
 *
 *   return (
 *     <div>
 *       {todos?.map(todo => <div key={todo.id}>{todo.text}</div>)}
 *     </div>
 *   );
 * }
 * ```
 */
export function createTodos(config: TodosConfig) {
  // Implementation
}
````

### 3. Document Error Codes

List all possible error codes and their meanings:

````typescript
/**
 * ## Error Codes
 *
 * This fragment can return the following error codes:
 *
 * - `NOT_FOUND` - Requested resource doesn't exist
 * - `VALIDATION_ERROR` - Input validation failed
 * - `RATE_LIMITED` - Too many requests (includes `retryAfter` field)
 * - `EXTERNAL_API_ERROR` - Third-party API failure
 *
 * ### Example Error Response
 * ```json
 * {
 *   "message": "Todo not found",
 *   "code": "NOT_FOUND",
 *   "todoId": "123"
 * }
 * ```
 */
````

## Deployment

### 1. Use Environment Variables

Never hardcode secrets:

```typescript
// ✅ Good - Use environment variables
const fragment = createMyFragment({
  apiKey: process.env.MY_API_KEY!,
  databaseUrl: process.env.DATABASE_URL!,
  debug: process.env.NODE_ENV === "development",
});

// ❌ Bad - Hardcoded secrets
const fragment = createMyFragment({
  apiKey: "sk-1234567890abcdef", // Never do this!
});
```

### 2. Validate Environment

Check required environment variables at startup:

```typescript
function validateEnvironment() {
  const required = ["MY_API_KEY", "DATABASE_URL"];
  const missing = required.filter((key) => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(", ")}`);
  }
}

export function createMyFragment(config: Config) {
  validateEnvironment();

  return createFragment(
    definition,
    {
      apiKey: process.env.MY_API_KEY!,
      databaseUrl: process.env.DATABASE_URL!,
      ...config,
    },
    routes,
  );
}
```

## Security

### 1. Validate All Input

Never trust user input:

```typescript
// ✅ Good - Validate file uploads
const uploadRoute = defineRoute({
  method: "POST",
  path: "/upload",
  handler: async ({ context }, { error, json }) => {
    const formData = await context.request.formData();
    const file = formData.get("file") as File;

    // Validate file exists
    if (!file) {
      return error({ message: "No file provided" }, 400);
    }

    // Validate file size
    if (file.size > 5 * 1024 * 1024) {
      // 5MB
      return error({ message: "File too large" }, 400);
    }

    // Validate file type
    const allowedTypes = ["image/jpeg", "image/png", "image/gif"];
    if (!allowedTypes.includes(file.type)) {
      return error({ message: "Invalid file type" }, 400);
    }

    // Validate file content (not just extension)
    const buffer = await file.arrayBuffer();
    if (!isValidImageBuffer(buffer)) {
      return error({ message: "Invalid image file" }, 400);
    }

    // Process file...
  },
});
```

### 2. Use HTTPS in Production

Configure secure headers:

```typescript
const fragment = createMyFragment(config, {
  middleware: [
    async (context, deps) => {
      // Add security headers
      const response = await context.next();

      if (response) {
        response.headers.set("X-Content-Type-Options", "nosniff");
        response.headers.set("X-Frame-Options", "DENY");
        response.headers.set("X-XSS-Protection", "1; mode=block");

        if (process.env.NODE_ENV === "production") {
          response.headers.set("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
        }
      }

      return response;
    },
  ],
});
```

### 3. Rate Limiting

Implement rate limiting to prevent abuse:

```typescript
const rateLimitMap = new Map<string, { count: number; resetTime: number }>();

const rateLimitMiddleware = async (context: MiddlewareContext) => {
  const ip = context.request.headers.get("x-forwarded-for") || "unknown";
  const now = Date.now();
  const windowMs = 15 * 60 * 1000; // 15 minutes
  const maxRequests = 100;

  const current = rateLimitMap.get(ip);

  if (!current || now > current.resetTime) {
    rateLimitMap.set(ip, { count: 1, resetTime: now + windowMs });
    return undefined; // Continue
  }

  if (current.count >= maxRequests) {
    return new Response(
      JSON.stringify({
        message: "Rate limit exceeded",
        code: "RATE_LIMITED",
        retryAfter: Math.ceil((current.resetTime - now) / 1000),
      }),
      {
        status: 429,
        headers: {
          "Content-Type": "application/json",
          "Retry-After": Math.ceil((current.resetTime - now) / 1000).toString(),
        },
      },
    );
  }

  current.count++;
  return undefined; // Continue
};
```

Following these best practices will help you create robust, maintainable, and user-friendly Fragno
fragments that integrate seamlessly across different frameworks and environments.
