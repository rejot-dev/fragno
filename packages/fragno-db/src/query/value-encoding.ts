import type { AnyTable } from "../schema/create";
import type { SQLProvider } from "../shared/providers";
import { serialize } from "../schema/type-conversion/serialize";
import { FragnoId } from "../schema/create";
import { generateRuntimeDefault } from "./column-defaults";

/**
 * Marker class for reference column values that need subquery resolution.
 * When a reference column receives a string (external ID), this marker tells
 * the query builder to generate a subquery to look up the internal ID.
 * @internal
 */
export class ReferenceSubquery {
  #referencedTable: AnyTable;
  #externalIdValue: string;

  constructor(referencedTable: AnyTable, externalIdValue: string) {
    this.#referencedTable = referencedTable;
    this.#externalIdValue = externalIdValue;
  }

  get referencedTable() {
    return this.#referencedTable;
  }

  get externalIdValue() {
    return this.#externalIdValue;
  }
}

/**
 * Encodes a record of values from the application format to database format.
 *
 * This function transforms object keys to match SQL column names and serializes
 * values according to the database provider's requirements (e.g., converting
 * JavaScript Date objects to numbers for SQLite).
 *
 * @param values - The record of values to encode in application format
 * @param table - The table schema definition containing column information
 * @param generateDefault - Whether to generate default values for undefined columns
 * @param provider - The SQL provider (sqlite, postgresql, mysql, etc.)
 * @param skipDriverConversions - Skip driver-level type conversions (Date->number, boolean->0/1, bigint->Buffer).
 *                                 Set to true when using ORMs like Drizzle that handle these conversions internally.
 * @returns A record with database-compatible column names and serialized values
 *
 * @example
 * ```ts
 * const encoded = encodeValues(
 *   { userId: 123, createdAt: new Date() },
 *   userTable,
 *   true,
 *   'sqlite'
 * );
 * // Returns: { user_id: 123, created_at: 1234567890 }
 * ```
 */
export function encodeValues(
  values: Record<string, unknown>,
  table: AnyTable,
  generateDefault: boolean,
  provider: SQLProvider,
  skipDriverConversions = false,
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const k in table.columns) {
    const col = table.columns[k];

    // Skip internal ID - never provided by user, auto-generated by database
    if (col.role === "internal-id") {
      continue;
    }
    let value = values[k];

    if (generateDefault && value === undefined) {
      // Only generate runtime defaults (defaultTo$), not static defaults (defaultTo).
      // Static defaults should be handled by the database via DEFAULT constraints.
      value = generateRuntimeDefault(col);
    }

    if (value !== undefined) {
      // Handle string references and FragnoId objects
      if (col.role === "reference") {
        if (typeof value === "string") {
          // String external ID - generate subquery
          const relation = Object.values(table.relations).find((rel) =>
            rel.on.some(([localCol]) => localCol === k),
          );
          if (relation) {
            result[col.name] = new ReferenceSubquery(relation.table, value);
            continue;
          }
          throw new Error(`Reference column ${k} not found in table ${table.name}`);
        } else if (value instanceof FragnoId) {
          // FragnoId object
          if (value.internalId !== undefined) {
            // If internal ID is populated, use it directly (no subquery needed)
            result[col.name] = value.internalId;
            continue;
          } else {
            // If internal ID is not populated, use external ID via subquery
            const relation = Object.values(table.relations).find((rel) =>
              rel.on.some(([localCol]) => localCol === k),
            );
            if (relation) {
              result[col.name] = new ReferenceSubquery(relation.table, value.externalId);
              continue;
            }
            throw new Error(`Reference column ${k} not found in table ${table.name}`);
          }
        }
      }

      result[col.name] = serialize(value, col, provider, skipDriverConversions);
    }
  }

  return result;
}
