import type { AnyTable, AnyColumn } from "../schema/create";
import type { SQLProvider } from "../shared/providers";
import { serialize } from "../schema/type-conversion/serialize";
import { FragnoId, FragnoReference } from "../schema/create";
import { generateRuntimeDefault } from "./column-defaults";

/**
 * Marker class for reference column values that need subquery resolution.
 * When a reference column receives a string (external ID), this marker tells
 * the query builder to generate a subquery to look up the internal ID.
 * @internal
 */
export class ReferenceSubquery {
  #referencedTable: AnyTable;
  #externalIdValue: string;

  constructor(referencedTable: AnyTable, externalIdValue: string) {
    this.#referencedTable = referencedTable;
    this.#externalIdValue = externalIdValue;
  }

  get referencedTable() {
    return this.#referencedTable;
  }

  get externalIdValue() {
    return this.#externalIdValue;
  }
}

/**
 * Resolves FragnoId or FragnoReference objects to their appropriate primitive values.
 *
 * This function handles the Fragno ID system's conversion to database values:
 * - FragnoReference objects are resolved to their internal IDs
 * - FragnoId objects are resolved based on the column role:
 *   - external-id: uses the external ID
 *   - internal-id: uses the internal ID (must be present)
 *   - reference: uses databaseId (internal ID if available, else external ID)
 *   - other: uses the external ID by default
 *
 * @param value - The value to resolve (may be FragnoId, FragnoReference, or any other value)
 * @param col - The column schema definition
 * @returns The resolved primitive value, or the original value if not a FragnoId/FragnoReference
 * @throws Error if internal ID is required but not available
 * @internal
 */
export function resolveFragnoIdValue(value: unknown, col: AnyColumn): unknown {
  // Handle FragnoReference objects (for reference columns)
  if (value instanceof FragnoReference) {
    return value.internalId;
  }

  // Handle FragnoId objects
  if (value instanceof FragnoId) {
    // For external ID columns, use the external ID
    if (col.role === "external-id") {
      return value.externalId;
    }
    // For internal ID columns, use the internal ID (must be present)
    if (col.role === "internal-id") {
      if (!value.internalId) {
        throw new Error(`FragnoId must have internalId for internal-id column ${col.name}`);
      }
      return value.internalId;
    }
    // For reference columns, prefer internal ID if available, else external ID
    if (col.role === "reference") {
      return value.databaseId;
    }
    // Default to external ID for other columns
    return value.externalId;
  }

  return value;
}

/**
 * Encodes a record of values from the application format to database format.
 *
 * This function transforms object keys to match SQL column names and serializes
 * values according to the database provider's requirements (e.g., converting
 * JavaScript Date objects to numbers for SQLite).
 *
 * @param values - The record of values to encode in application format
 * @param table - The table schema definition containing column information
 * @param generateDefault - Whether to generate default values for undefined columns
 * @param provider - The SQL provider (sqlite, postgresql, mysql, etc.)
 * @param skipDriverConversions - Skip driver-level type conversions (Date->number, boolean->0/1, bigint->Buffer).
 *                                 Set to true when using ORMs like Drizzle that handle these conversions internally.
 * @returns A record with database-compatible column names and serialized values
 *
 * @example
 * ```ts
 * const encoded = encodeValues(
 *   { userId: 123, createdAt: new Date() },
 *   userTable,
 *   true,
 *   'sqlite'
 * );
 * // Returns: { user_id: 123, created_at: 1234567890 }
 * ```
 */
export function encodeValues(
  values: Record<string, unknown>,
  table: AnyTable,
  generateDefault: boolean,
  provider: SQLProvider,
  skipDriverConversions = false,
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const k in table.columns) {
    const col = table.columns[k];

    // Skip internal ID - never provided by user, auto-generated by database
    if (col.role === "internal-id") {
      continue;
    }
    let value = values[k];

    if (generateDefault && value === undefined) {
      // Only generate runtime defaults (defaultTo$), not static defaults (defaultTo).
      // Static defaults should be handled by the database via DEFAULT constraints.
      value = generateRuntimeDefault(col);
    }

    if (value !== undefined) {
      // Handle reference columns: strings or FragnoIds without internal IDs need subqueries
      if (col.role === "reference") {
        let needsSubquery = false;
        let externalIdForSubquery: string | undefined;

        if (typeof value === "string") {
          // String external ID - needs subquery
          needsSubquery = true;
          externalIdForSubquery = value;
        } else if (value instanceof FragnoId && value.internalId === undefined) {
          // FragnoId without internal ID - needs subquery
          needsSubquery = true;
          externalIdForSubquery = value.externalId;
        } else if (value instanceof FragnoId && value.internalId !== undefined) {
          // FragnoId with internal ID - use it directly without serialization
          // Internal IDs are already in database format (bigint), no driver conversion needed
          result[col.name] = value.internalId;
          continue;
        } else if (value instanceof FragnoReference) {
          // FragnoReference - use internal ID directly without serialization
          result[col.name] = value.internalId;
          continue;
        }

        if (needsSubquery) {
          const relation = Object.values(table.relations).find((rel) =>
            rel.on.some(([localCol]) => localCol === k),
          );
          if (relation) {
            result[col.name] = new ReferenceSubquery(relation.table, externalIdForSubquery!);
            continue;
          }
          throw new Error(`Reference column ${k} not found in table ${table.name}`);
        }
      }

      // Resolve FragnoId/FragnoReference to primitive values before serialization
      const resolvedValue = resolveFragnoIdValue(value, col);
      result[col.name] = serialize(resolvedValue, col, provider, skipDriverConversions);
    }
  }

  return result;
}
