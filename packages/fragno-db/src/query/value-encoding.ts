import type { AnyTable, AnyColumn } from "../schema/create";
import { FragnoId, FragnoReference } from "../schema/create";
import {
  generateDatabaseDefault,
  generateRuntimeDefault,
  type RuntimeDefaultContext,
} from "./column-defaults";

/**
 * Marker class for reference column values that need subquery resolution.
 * When a reference column receives a string (external ID), this marker tells
 * the query builder to generate a subquery to look up the internal ID.
 * @internal
 */
export class ReferenceSubquery {
  #referencedTable: AnyTable;
  #externalIdValue: string;

  constructor(referencedTable: AnyTable, externalIdValue: string) {
    this.#referencedTable = referencedTable;
    this.#externalIdValue = externalIdValue;
  }

  get referencedTable() {
    return this.#referencedTable;
  }

  get externalIdValue() {
    return this.#externalIdValue;
  }
}

/**
 * Resolves FragnoId or FragnoReference objects to their appropriate primitive values.
 *
 * This function handles the Fragno ID system's conversion to database values:
 * - FragnoReference objects are resolved to their internal IDs
 * - FragnoId objects are resolved based on the column role:
 *   - external-id: uses the external ID
 *   - internal-id: uses the internal ID (must be present)
 *   - reference: uses databaseId (internal ID if available, else external ID)
 *   - other: uses the external ID by default
 *
 * @param value - The value to resolve (may be FragnoId, FragnoReference, or any other value)
 * @param col - The column schema definition
 * @returns The resolved primitive value, or the original value if not a FragnoId/FragnoReference
 * @throws Error if internal ID is required but not available
 * @internal
 */
export function resolveFragnoIdValue(value: unknown, col: AnyColumn): unknown {
  // Handle FragnoReference objects (for reference columns)
  if (value instanceof FragnoReference) {
    return value.internalId;
  }

  // Handle FragnoId objects
  if (value instanceof FragnoId) {
    // For external ID columns, use the external ID
    if (col.role === "external-id") {
      return value.externalId;
    }
    // For internal ID columns, use the internal ID (must be present)
    if (col.role === "internal-id") {
      if (value.internalId === undefined) {
        throw new Error(`FragnoId must have internalId for internal-id column ${col.name}`);
      }
      return value.internalId;
    }
    // For reference columns, prefer internal ID if available, else external ID
    if (col.role === "reference") {
      return value.databaseId;
    }
    // Default to external ID for other columns
    return value.externalId;
  }

  return value;
}

/**
 * Encodes a record of values from the application format to resolved format.
 *
 * This function:
 * - Transforms object keys from ORM names to database column names
 * - Resolves FragnoId/FragnoReference objects to primitive values
 * - Generates default values for undefined columns
 * - Creates ReferenceSubquery markers for external ID lookups
 *
 * Note: This function does NOT serialize values (Date → number, bigint → Buffer, etc.).
 * Use UnitOfWorkEncoder.encode() to apply driver-specific serialization after this step.
 *
 * @param values - The record of values to encode in application format
 * @param table - The table schema definition containing column information
 * @param generateDefault - Whether to generate default values for undefined columns
 * @returns A record with database column names and resolved (but not serialized) values
 *
 * @example
 * ```ts
 * const encoded = encodeValues(
 *   { userId: 123, createdAt: new Date() },
 *   userTable,
 *   true
 * );
 * // Returns: { user_id: 123, created_at: Date } (not yet serialized)
 * ```
 */
export function encodeValues(
  values: Record<string, unknown>,
  table: AnyTable,
  generateDefault: boolean,
  runtimeDefaults: RuntimeDefaultContext = {},
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const k in table.columns) {
    const col = table.columns[k];

    // Skip internal ID - never provided by user, auto-generated by database
    if (col.role === "internal-id") {
      continue;
    }
    let value = values[k];

    if (generateDefault && value === undefined) {
      // Only generate runtime defaults (defaultTo$), not static defaults (defaultTo).
      // Static defaults should be handled by the database via DEFAULT constraints.
      value = generateRuntimeDefault(col, runtimeDefaults);
    }

    if (value !== undefined) {
      // Handle reference columns: strings or FragnoIds without internal IDs need subqueries
      if (col.role === "reference") {
        let needsSubquery = false;
        let externalIdForSubquery: string | undefined;

        if (typeof value === "string") {
          // String external ID - needs subquery
          needsSubquery = true;
          externalIdForSubquery = value;
        } else if (value instanceof FragnoId && value.internalId === undefined) {
          // FragnoId without internal ID - needs subquery
          needsSubquery = true;
          externalIdForSubquery = value.externalId;
        } else if (value instanceof FragnoId && value.internalId !== undefined) {
          // FragnoId with internal ID - use it directly (will be serialized later)
          result[col.name] = value.internalId;
          continue;
        } else if (value instanceof FragnoReference) {
          // FragnoReference - use internal ID directly (will be serialized later)
          result[col.name] = value.internalId;
          continue;
        }

        if (needsSubquery) {
          const relation = Object.values(table.relations).find((rel) =>
            rel.on.some(([localCol]) => localCol === k),
          );
          if (relation) {
            result[col.name] = new ReferenceSubquery(relation.table, externalIdForSubquery!);
            continue;
          }
          throw new Error(`Reference column ${k} not found in table ${table.name}`);
        }
      }

      // Resolve FragnoId/FragnoReference to primitive values (serialization happens later)
      const resolvedValue = resolveFragnoIdValue(value, col);
      result[col.name] = resolvedValue;
    }
  }

  return result;
}

/**
 * Encode values and apply database defaults in-process.
 *
 * This is intended for adapters that cannot rely on database DEFAULT constraints,
 * such as the in-memory adapter.
 *
 * @internal
 */
export function encodeValuesWithDbDefaults(
  values: Record<string, unknown>,
  table: AnyTable,
  runtimeDefaults: RuntimeDefaultContext = {},
): Record<string, unknown> {
  const resolved = encodeValues(values, table, true, runtimeDefaults);

  for (const columnKey of Object.keys(table.columns)) {
    const column = table.columns[columnKey];
    if (column.role === "internal-id") {
      continue;
    }

    if (Object.prototype.hasOwnProperty.call(resolved, column.name)) {
      continue;
    }

    const fallback = generateDatabaseDefault(column, runtimeDefaults);
    if (fallback !== undefined) {
      resolved[column.name] = fallback;
    }
  }

  return resolved;
}
