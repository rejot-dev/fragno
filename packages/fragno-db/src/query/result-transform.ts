import type { AnyColumn, AnyTable } from "../schema/create";
import type { SQLProvider } from "../shared/providers";
import { deserialize, serialize } from "../schema/serialize";
import { FragnoId, FragnoReference } from "../schema/create";
import { createId } from "../id";

/**
 * Marker class for reference column values that need subquery resolution.
 * When a reference column receives a string (external ID), this marker tells
 * the query builder to generate a subquery to look up the internal ID.
 * @internal
 */
export class ReferenceSubquery {
  #referencedTable: AnyTable;
  #externalIdValue: string;

  constructor(referencedTable: AnyTable, externalIdValue: string) {
    this.#referencedTable = referencedTable;
    this.#externalIdValue = externalIdValue;
  }

  get referencedTable() {
    return this.#referencedTable;
  }

  get externalIdValue() {
    return this.#externalIdValue;
  }
}

/**
 * Generate a runtime default value for a column that has defaultTo$()
 *
 * Only generates values for runtime defaults (defaultTo$), NOT static defaults (defaultTo).
 * Static defaults should be handled by the database via DEFAULT constraints.
 *
 * @param column - The column with a default value configuration
 * @returns The generated default value, or undefined if the column has no runtime default
 *
 * @internal
 */
export function generateRuntimeDefault(column: AnyColumn): unknown {
  // Check if column has a default value configuration
  if (!column.default) {
    return undefined;
  }

  // If it's a static default value (defaultTo), return undefined
  // as the database should handle this via DEFAULT constraint
  if ("value" in column.default) {
    return undefined;
  }

  // If it's a database-level special function (defaultTo(b => b.now())), return undefined
  // as the database should handle this via DEFAULT NOW() or equivalent
  if ("dbSpecial" in column.default) {
    return undefined;
  }

  // Handle runtime defaults (defaultTo$)
  const runtime = column.default.runtime;

  if (runtime === "cuid") {
    return createId();
  }

  if (runtime === "now") {
    return new Date();
  }

  if (typeof runtime === "function") {
    return runtime();
  }

  return undefined;
}

/**
 * Encodes a record of values from the application format to database format.
 *
 * This function transforms object keys to match SQL column names and serializes
 * values according to the database provider's requirements (e.g., converting
 * JavaScript Date objects to numbers for SQLite).
 *
 * @param values - The record of values to encode in application format
 * @param table - The table schema definition containing column information
 * @param generateDefault - Whether to generate default values for undefined columns
 * @param provider - The SQL provider (sqlite, postgresql, mysql, etc.)
 * @returns A record with database-compatible column names and serialized values
 *
 * @example
 * ```ts
 * const encoded = encodeValues(
 *   { userId: 123, createdAt: new Date() },
 *   userTable,
 *   true,
 *   'sqlite'
 * );
 * // Returns: { user_id: 123, created_at: 1234567890 }
 * ```
 */
export function encodeValues(
  values: Record<string, unknown>,
  table: AnyTable,
  generateDefault: boolean,
  provider: SQLProvider,
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const k in table.columns) {
    const col = table.columns[k];

    // Skip internal ID - never provided by user, auto-generated by database
    if (col.role === "internal-id") {
      continue;
    }
    let value = values[k];

    if (generateDefault && value === undefined) {
      // Only generate runtime defaults (defaultTo$), not static defaults (defaultTo).
      // Static defaults should be handled by the database via DEFAULT constraints.
      value = generateRuntimeDefault(col);
    }

    if (value !== undefined) {
      // Handle string references - convert external ID to internal ID via subquery
      if (col.role === "reference" && typeof value === "string") {
        // Find relation that uses this column
        const relation = Object.values(table.relations).find((rel) =>
          rel.on.some(([localCol]) => localCol === k),
        );
        if (relation) {
          result[col.name] = new ReferenceSubquery(relation.table, value);
          continue;
        }

        throw new Error(`Reference column ${k} not found in table ${table.name}`);
      }

      result[col.name] = serialize(value, col, provider);
    }
  }

  return result;
}

/**
 * Decodes a database result record to application format.
 *
 * This function transforms database column names back to application property names
 * and deserializes values according to the database provider's format (e.g., converting
 * SQLite integers back to JavaScript Date objects).
 *
 * Supports relation data encoded with the pattern `relationName:columnName`.
 *
 * @param result - The raw database result record
 * @param table - The table schema definition containing column and relation information
 * @param provider - The SQL provider (sqlite, postgresql, mysql, etc.)
 * @returns A record in application format with deserialized values
 *
 * @example
 * ```ts
 * const decoded = decodeResult(
 *   { user_id: 123, created_at: 1234567890, 'posts:title': 'Hello' },
 *   userTable,
 *   'sqlite'
 * );
 * // Returns: { userId: 123, createdAt: Date, posts: { title: 'Hello' } }
 * ```
 */
export function decodeResult(
  result: Record<string, unknown>,
  table: AnyTable,
  provider: SQLProvider,
): Record<string, unknown> {
  const output: Record<string, unknown> = {};
  // First pass: collect all column values
  const columnValues: Record<string, unknown> = {};

  // Collect all relation data (including nested) keyed by relation name
  const relationData: Record<string, Record<string, unknown>> = {};

  for (const k in result) {
    const colonIndex = k.indexOf(":");
    const value = result[k];

    // Direct column (no colon)
    if (colonIndex === -1) {
      const col = table.columns[k];
      if (!col) {
        continue;
      }

      // Store all column values (including hidden ones for FragnoId creation)
      columnValues[k] = deserialize(value, col, provider);
      continue;
    }

    // Relation column (has colon)
    const relationName = k.slice(0, colonIndex);
    const remainder = k.slice(colonIndex + 1);

    const relation = table.relations[relationName];
    if (relation === undefined) {
      continue;
    }

    // Collect relation data with the remaining key path
    relationData[relationName] ??= {};
    relationData[relationName][remainder] = value;
  }

  // Process each relation's data recursively
  for (const relationName in relationData) {
    const relation = table.relations[relationName];
    if (!relation) {
      continue;
    }

    // Recursively decode the relation data
    output[relationName] = decodeResult(relationData[relationName], relation.table, provider);
  }

  // Second pass: create output with FragnoId objects where appropriate
  for (const k in columnValues) {
    const col = table.columns[k];
    if (!col) {
      continue;
    }

    // Filter out hidden columns (like _internalId, _version) from results
    if (col.isHidden) {
      continue;
    }

    // For external ID columns, create FragnoId if we have both external and internal IDs
    if (col.role === "external-id" && columnValues["_internalId"] !== undefined) {
      output[k] = new FragnoId({
        externalId: columnValues[k] as string,
        internalId: columnValues["_internalId"] as bigint,
        // _version is always selected as a hidden column, so it should always be present
        version: columnValues["_version"] as number,
      });
    } else if (col.role === "reference") {
      // For reference columns, create FragnoReference with internal ID
      output[k] = FragnoReference.fromInternal(columnValues[k] as bigint);
    } else {
      output[k] = columnValues[k];
    }
  }

  return output;
}
