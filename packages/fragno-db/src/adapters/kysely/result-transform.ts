import type { AnyTable } from "../../schema/create";
import type { SQLProvider } from "../../shared/providers";
import { deserialize, serialize } from "../../schema/serialize";
import { FragnoId, FragnoReference } from "../../schema/create";

/**
 * Marker class for reference column values that need subquery resolution.
 * When a reference column receives a string (external ID), this marker tells
 * the query builder to generate a subquery to look up the internal ID.
 * @internal
 */
export class ReferenceSubquery {
  #referencedTable: AnyTable;
  #externalIdValue: string;

  constructor(referencedTable: AnyTable, externalIdValue: string) {
    this.#referencedTable = referencedTable;
    this.#externalIdValue = externalIdValue;
  }

  get referencedTable() {
    return this.#referencedTable;
  }

  get externalIdValue() {
    return this.#externalIdValue;
  }
}

/**
 * Encodes a record of values from the application format to database format.
 *
 * This function transforms object keys to match SQL column names and serializes
 * values according to the database provider's requirements (e.g., converting
 * JavaScript Date objects to numbers for SQLite).
 *
 * @param values - The record of values to encode in application format
 * @param table - The table schema definition containing column information
 * @param generateDefault - Whether to generate default values for undefined columns
 * @param provider - The SQL provider (sqlite, postgresql, mysql, etc.)
 * @returns A record with database-compatible column names and serialized values
 *
 * @example
 * ```ts
 * const encoded = encodeValues(
 *   { userId: 123, createdAt: new Date() },
 *   userTable,
 *   true,
 *   'sqlite'
 * );
 * // Returns: { user_id: 123, created_at: 1234567890 }
 * ```
 */
export function encodeValues(
  values: Record<string, unknown>,
  table: AnyTable,
  generateDefault: boolean,
  provider: SQLProvider,
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const k in table.columns) {
    const col = table.columns[k];

    // Skip internal ID - never provided by user, auto-generated by database
    if (col.role === "internal-id") {
      continue;
    }

    // Set version to 0 for inserts (system-managed)
    if (col.role === "version") {
      if (generateDefault) {
        result[col.name] = 0;
      }
      continue;
    }

    let value = values[k];

    if (generateDefault && value === undefined) {
      // prefer generating them on runtime to avoid SQLite's problem with column default value being ignored when insert
      value = col.generateDefaultValue();
    }

    if (value !== undefined) {
      // Handle string references - convert external ID to internal ID via subquery
      if (col.role === "reference" && typeof value === "string") {
        // Find relation that uses this column
        const relation = Object.values(table.relations).find((rel) =>
          rel.on.some(([localCol]) => localCol === k),
        );
        if (relation) {
          result[col.name] = new ReferenceSubquery(relation.table, value);
          continue;
        }

        throw new Error(`Reference column ${k} not found in table ${table.name}`);
      }

      result[col.name] = serialize(value, col, provider);
    }
  }

  return result;
}

/**
 * Decodes a database result record to application format.
 *
 * This function transforms database column names back to application property names
 * and deserializes values according to the database provider's format (e.g., converting
 * SQLite integers back to JavaScript Date objects).
 *
 * Supports relation data encoded with the pattern `relationName:columnName`.
 *
 * @param result - The raw database result record
 * @param table - The table schema definition containing column and relation information
 * @param provider - The SQL provider (sqlite, postgresql, mysql, etc.)
 * @returns A record in application format with deserialized values
 *
 * @example
 * ```ts
 * const decoded = decodeResult(
 *   { user_id: 123, created_at: 1234567890, 'posts:title': 'Hello' },
 *   userTable,
 *   'sqlite'
 * );
 * // Returns: { userId: 123, createdAt: Date, posts: { title: 'Hello' } }
 * ```
 */
export function decodeResult(
  result: Record<string, unknown>,
  table: AnyTable,
  provider: SQLProvider,
): Record<string, unknown> {
  const output: Record<string, unknown> = {};

  // First pass: collect all column values
  const columnValues: Record<string, unknown> = {};

  // Collect hidden columns for each relation (for FragnoId creation)
  const relationHiddenColumns: Record<string, Record<string, unknown>> = {};

  for (const k in result) {
    const segments = k.split(":", 2);
    const value = result[k];

    if (segments.length === 1) {
      const col = table.columns[k];
      if (!col) {
        continue;
      }

      // Store all column values (including hidden ones for FragnoId creation)
      columnValues[k] = deserialize(value, col, provider);
    }

    if (segments.length === 2) {
      const [relationName, colName] = segments;
      const relation = table.relations[relationName];
      if (relation === undefined) {
        continue;
      }

      const col = relation.table.columns[colName];
      if (col === undefined) {
        continue;
      }

      const deserializedValue = deserialize(value, col, provider);

      // Store hidden columns for later FragnoId creation
      if (col.isHidden) {
        relationHiddenColumns[relationName] ??= {};
        relationHiddenColumns[relationName][colName] = deserializedValue;
        continue;
      }

      output[relationName] ??= {};
      const obj = output[relationName] as Record<string, unknown>;
      obj[colName] = deserializedValue;
    }
  }

  // Second pass: create output with FragnoId objects where appropriate
  for (const k in columnValues) {
    const col = table.columns[k];
    if (!col) {
      continue;
    }

    // Filter out hidden columns (like _internalId, _version) from results
    if (col.isHidden) {
      continue;
    }

    // For external ID columns, create FragnoId if we have both external and internal IDs
    if (col.role === "external-id" && columnValues["_internalId"] !== undefined) {
      output[k] = new FragnoId({
        externalId: columnValues[k] as string,
        internalId: columnValues["_internalId"] as bigint,
        // _version is always selected as a hidden column, so it should always be present
        version: columnValues["_version"] as number,
      });
    } else if (col.role === "reference") {
      // For reference columns, create FragnoReference with internal ID
      output[k] = FragnoReference.fromInternal(columnValues[k] as bigint);
    } else {
      output[k] = columnValues[k];
    }
  }

  // Third pass: transform external-id columns in relations to FragnoId
  for (const relationName in output) {
    const relation = table.relations[relationName];
    if (!relation) {
      continue;
    }

    const relationData = output[relationName] as Record<string, unknown>;
    const hiddenCols = relationHiddenColumns[relationName];

    if (!hiddenCols) {
      continue;
    }

    // Check each column in the relation data
    for (const colName in relationData) {
      const col = relation.table.columns[colName];
      if (!col) {
        continue;
      }

      // Transform external-id columns to FragnoId if we have _internalId and _version
      if (
        col.role === "external-id" &&
        hiddenCols["_internalId"] !== undefined &&
        hiddenCols["_version"] !== undefined
      ) {
        relationData[colName] = new FragnoId({
          externalId: relationData[colName] as string,
          internalId: hiddenCols["_internalId"] as bigint,
          version: hiddenCols["_version"] as number,
        });
      }
    }
  }

  return output;
}
