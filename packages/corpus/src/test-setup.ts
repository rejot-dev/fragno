import { writeFileSync, mkdirSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { loadAllSubjects } from "./parser";

const __dirname = fileURLToPath(new URL(".", import.meta.url));
const TEMP_TEST_DIR = join(__dirname, "../corpus-tests");

/**
 * Global setup for vitest that parses all markdown files
 * and generates temporary test files from @fragno-test blocks
 */
export async function setup() {
  // Create temp directory (if it doesn't exist)
  mkdirSync(TEMP_TEST_DIR, { recursive: true });

  try {
    // Load all subjects
    const subjects = loadAllSubjects();

    // Generate test files for each subject
    for (const subject of subjects) {
      // Skip if no tests
      if (subject.examples.length === 0) {
        console.log(`⊘ Skipped ${subject.id} (no test directives found)`);
        continue;
      }

      const testFileName = `${subject.id}.generated.test.ts`;
      const testFilePath = join(TEMP_TEST_DIR, testFileName);

      // Generate test file content
      // Combine all prelude and testInit blocks into a single string
      const allPrelude = subject.prelude.map((block) => block.code).join("\n\n");
      const allTestInit = subject.testInit.map((block) => block.code).join("\n\n");
      const allInit = [allPrelude, allTestInit].filter(Boolean).join("\n\n");

      // Make describe async if there's init code (for database setup)
      const isAsync = allInit.length > 0 ? "async " : "";

      let testFileContent = `/* eslint-disable */
// Auto-generated test file for subject: ${subject.title}
// DO NOT EDIT - This file is generated by test-setup.ts

import { describe, it, expect } from "vitest";
${subject.imports}

describe("${subject.id}", ${isAsync}() => {
${allInit ? `${allInit}\n` : ""}
`;

      for (let i = 0; i < subject.examples.length; i++) {
        const example = subject.examples[i];
        // Priority: testName (from comment) > id (from directive) > default
        const testName = example.testName || example.id || `test ${i + 1}`;

        // Use it.skip for types-only tests
        const itMethod = example.typesOnly ? "it.skip" : "it";
        testFileContent += `  ${itMethod}("${testName}", async () => {\n`;

        // Indent the code and strip export statements
        // Also transform declare statements to const with type casts
        // Filter out import statements that can't be inside functions
        const indentedCode = example.code
          .split("\n")
          .filter((line) => {
            // Remove import statements from inside test blocks (they're invalid)
            const trimmed = line.trim();
            return !trimmed.startsWith("import ") && !trimmed.startsWith("import type ");
          })
          .map((line) => {
            // Remove 'export ' or 'export\t' from the beginning of lines (with optional leading whitespace)
            let stripped = line.replace(/^(\s*)export\s+/, "$1");

            // Transform declare const X: Y; to const X = {} as Y;
            stripped = stripped.replace(
              /^(\s*)declare\s+(const\s+\w+):\s*(.+);/,
              "$1$2 = {} as $3;",
            );

            return `    ${stripped}`;
          })
          .join("\n");
        testFileContent += `${indentedCode}\n`;
        testFileContent += `  });\n\n`;
      }

      testFileContent += `});\n`;

      // Ensure directory exists
      mkdirSync(dirname(testFilePath), { recursive: true });

      // Write test file
      writeFileSync(testFilePath, testFileContent, "utf-8");
    }

    console.log(`✓ Generated ${subjects.length} test file(s) in ${TEMP_TEST_DIR}`);
  } catch (error) {
    if (error instanceof Error) {
      console.error("Error generating test files:", error.message);
    }
    // Don't throw - allow tests to continue even if generation fails
  }
}
