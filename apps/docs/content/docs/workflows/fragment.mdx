---
title: Workflow Fragment
description: Run long-lived workflows with durable steps, events, and retries.
icon: NotebookTabs
---

The Workflows Fragment lets you define long-running processes with durable steps, retries, and
waits. It stores workflow state in your database and exposes HTTP endpoints to create, control, and
observe workflow instances.

## Install

```bash
npm install @fragno-dev/fragment-workflows @fragno-dev/db
```

## Define a Workflow

```ts title="lib/workflows.ts"
import {
  defineWorkflow,
  type WorkflowEvent,
  type WorkflowStep,
} from "@fragno-dev/fragment-workflows";

type ApprovalParams = {
  requestId: string;
  amount: number;
};

type ApprovalEvent = { approved: boolean };

type FulfillmentEvent = { confirmationId: string };

export const ApprovalWorkflow = defineWorkflow(
  { name: "approval-workflow" },
  async (event: WorkflowEvent<ApprovalParams>, step: WorkflowStep) => {
    const approval = await step.waitForEvent<ApprovalEvent>("approval", {
      type: "approval",
      timeout: "15 min",
    });

    await step.sleep("cooldown", "2 s");

    const fulfillment = await step.waitForEvent<FulfillmentEvent>("fulfillment", {
      type: "fulfillment",
      timeout: "15 min",
    });

    return { request: event.payload, approval, fulfillment };
  },
);

export const workflows = {
  approval: ApprovalWorkflow,
} as const;
```

## Schema validation + output typing

If you provide a Standard Schema, params are validated on create/createBatch. If you provide an
`outputSchema`, the workflow output is typed end-to-end.

```ts
import { z } from "zod";

const paramsSchema = z.object({ requestId: z.string(), amount: z.number() });
const outputSchema = z.object({ confirmationId: z.string() });

export const ApprovalWorkflow = defineWorkflow(
  { name: "approval-workflow", schema: paramsSchema, outputSchema },
  async (event, step) => {
    // ...
    return { confirmationId: "conf_123" };
  },
);
```

## Create the Fragment Server

```ts title="lib/workflows-fragment.ts"
import { defaultFragnoRuntime, instantiate } from "@fragno-dev/core";
import { createDurableHooksProcessor, type DatabaseAdapter } from "@fragno-dev/db";
import { createDurableHooksDispatcher } from "@fragno-dev/db/dispatchers/node";
import {
  createWorkflowsRunner,
  workflowsFragmentDefinition,
  workflowsRoutesFactory,
} from "@fragno-dev/fragment-workflows";
import { workflows } from "./workflows";

export function createWorkflowsFragmentServer(adapter: DatabaseAdapter<any>) {
  const runtime = defaultFragnoRuntime;
  let runner: ReturnType<typeof createWorkflowsRunner> | null = null;

  const config = { workflows, runtime, enableRunnerTick: true };
  const fragment = instantiate(workflowsFragmentDefinition)
    .withConfig(config)
    .withRoutes([workflowsRoutesFactory])
    .withOptions({ databaseAdapter: adapter })
    .build();

  runner = createWorkflowsRunner({ fragment, workflows, runtime });
  config.runner = runner;

  const processor = createDurableHooksProcessor(fragment);
  if (!processor) {
    throw new Error("Durable hooks not configured for workflows fragment.");
  }

  const dispatcher = createDurableHooksDispatcher({
    processor,
    pollIntervalMs: 2000,
  });

  return { fragment, dispatcher };
}
```

## Runtime Injection

Workflows require a `FragnoRuntime` for time and randomness. Use `defaultFragnoRuntime` for
production, or inject a deterministic runtime for tests and model checking.

## Testing Workflows

Use the test harness to drive the runner and control time:

```ts title="lib/workflows.test.ts"
import {
  createWorkflowsTestHarness,
  createWorkflowsTestRuntime,
} from "@fragno-dev/fragment-workflows/test";
import { workflows } from "./workflows";

const runtime = createWorkflowsTestRuntime({ startAt: 0, seed: 42 });
const harness = await createWorkflowsTestHarness({
  workflows,
  adapter: { type: "drizzle-pglite" },
  runtime,
});

const instanceId = await harness.createInstance("approval", {
  params: { requestId: "req_1", amount: 125 },
});

await harness.runUntilIdle();
await harness.sendEvent("approval", instanceId, {
  type: "approval",
  payload: { approved: true },
});

harness.clock.advanceBy("2 s");
await harness.runUntilIdle();

const status = await harness.getStatus("approval", instanceId);
```

## HTTP Tick Integration

If you want an external scheduler to drive execution, keep `enableRunnerTick: true` and send
`POST /_runner/tick` to your fragment. A durable hook handler or cron can trigger it:

```ts
await fetch("https://your-app.example.com/api/workflows/_runner/tick", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ maxInstances: 10, maxSteps: 100 }),
});
```

## Next Steps

- Explore the HTTP surface in the [API routes reference](/docs/workflows/routes).
- Manage workflows with the [CLI](/docs/workflows/cli).
