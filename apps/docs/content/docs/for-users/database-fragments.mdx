---
title: Database Fragments
description: Integrating Fragments that include a database layer
---

import { Callout } from "fumadocs-ui/components/callout";
import { Step, Steps } from "fumadocs-ui/components/steps";

Some Fragno Fragments include a built-in database layer for persistent storage. When integrating
these Fragments, you need to provide a **database adapter** that connects the Fragment to your
existing database.

<Callout title="Fragment Handles Schema" type="info">
  The Fragment defines its own schema and handles migrations. You just provide the database
  connection - no need to manually create tables or write SQL.
</Callout>

## Identifying Database Fragments

A Fragment uses the database layer if its documentation mentions `FragnoPublicConfigWithDatabase` or
requires a `databaseAdapter` option.

Check the Fragment's creation function:

```typescript
// Fragment without database
createExampleFragment(config, options);

// Fragment with database - requires databaseAdapter
createCommentFragment(config, { databaseAdapter });
```

## Quick Start

<Steps>

<Step>
### Install Database Adapter Package

```bash
npm install @fragno-dev/db
```

</Step>

<Step>
### Create Database Adapter

Choose the adapter that matches your ORM:

```typescript title="lib/database-adapter.ts" tab="Kysely"
import { KyselyAdapter } from "@fragno-dev/db/adapters/kysely";
import { db } from "./database"; // Your existing Kysely instance

export const fragmentDbAdapter = new KyselyAdapter({
  db,
  provider: "postgresql", // or "mysql", "sqlite"
});
```

```typescript title="lib/database-adapter.ts" tab="Drizzle"
import { DrizzleAdapter } from "@fragno-dev/db/adapters/drizzle";
import { db } from "./database"; // Your existing Drizzle instance

export const fragmentDbAdapter = new DrizzleAdapter({
  db,
  provider: "postgresql", // or "mysql", "sqlite"
});
```

</Step>

<Step>
### Pass Adapter to Fragment

```typescript title="lib/comment-fragment-server.ts"
import { createCommentFragment } from "@fragno-dev/comment-fragment";
import { fragmentDbAdapter } from "./database-adapter";

export function createCommentFragmentInstance() {
  return createCommentFragment(
    {
      // Fragment-specific config
    },
    {
      // Fragno config with database adapter
      databaseAdapter: fragmentDbAdapter,
    },
  );
}
```

</Step>

<Step>
### Run Migrations

Generate and apply database migrations:

```bash
# Generate migration files
npx fragno-cli db generate lib/comment-fragment-server.ts

# Review generated migrations in fragno-db/migrations/

# Apply migrations
npx fragno-cli db migrate lib/comment-fragment-server.ts
```

</Step>

</Steps>

## Database Adapters

### Kysely Adapter

The Kysely adapter integrates with your existing [Kysely](https://kysely.dev/) instance.

**Installation:**

```bash
npm install kysely @fragno-dev/db
```

**Configuration:**

```typescript
import { KyselyAdapter } from "@fragno-dev/db/adapters/kysely";
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";

// Your existing Kysely setup
export const db = new Kysely({
  dialect: new PostgresDialect({
    pool: new Pool({
      host: process.env.DB_HOST,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
    }),
  }),
});

// Create adapter for Fragments
export const fragmentDbAdapter = new KyselyAdapter({
  db,
  provider: "postgresql", // "mysql" or "sqlite"
});
```

**Supported Providers:**

- PostgreSQL (`"postgresql"`)
- MySQL (`"mysql"`)
- SQLite (`"sqlite"`)

### Drizzle Adapter

The Drizzle adapter integrates with your existing [Drizzle ORM](https://orm.drizzle.team/) instance.

**Installation:**

```bash
npm install drizzle-orm @fragno-dev/db
```

**Configuration:**

```typescript
import { DrizzleAdapter } from "@fragno-dev/db/adapters/drizzle";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

// Your existing Drizzle setup
const pool = new Pool({
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});

export const db = drizzle(pool);

// Create adapter for Fragments
export const fragmentDbAdapter = new DrizzleAdapter({
  db,
  provider: "postgresql", // "mysql" or "sqlite"
});
```

**Supported Providers:**

- PostgreSQL (`"postgresql"`)
- MySQL (`"mysql"`)
- SQLite (`"sqlite"`)

## Managing Migrations

### Generating Migrations

The Fragno CLI automatically detects schema changes and generates migration files:

```bash
npx fragno-cli db generate path/to/fragment-instance.ts
```

This command:

1. Imports your Fragment instance
2. Compares the Fragment's schema with your database
3. Generates SQL migration files in `fragno-db/migrations/`

**Example output:**

```
Generated migration: fragno-db/migrations/001_initial_schema.sql
Generated migration: fragno-db/migrations/002_add_rating_column.sql
```

### Reviewing Migrations

Always review generated migrations before applying them:

```sql title="fragno-db/migrations/001_initial_schema.sql"
-- Migration: Initial schema
-- Fragment: comment-fragment
-- Generated: 2025-01-15T10:30:00Z
CREATE TABLE fragno_comment_fragment_comment (
  id VARCHAR(255) PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW (),
  user_id VARCHAR(255) NOT NULL
);

CREATE INDEX idx_comment_user ON fragno_comment_fragment_comment (user_id);
```

<Callout title="Table Namespacing" type="info">
  Fragment tables are automatically prefixed (e.g., `fragno_comment_fragment_comment`). This
  prevents conflicts with your existing tables.
</Callout>

### Applying Migrations

Run pending migrations:

```bash
npx fragno-cli db migrate path/to/fragment-instance.ts
```

This command:

1. Checks which migrations have been applied
2. Runs any pending migrations in order
3. Records applied migrations in a tracking table

### Checking Migration Status

View the current migration state:

```bash
npx fragno-cli db info path/to/fragment-instance.ts
```

**Example output:**

```
Fragment: comment-fragment
Database: postgresql

Applied Migrations:
âœ“ 001_initial_schema.sql (2025-01-15 10:35:22)

Pending Migrations:
- 002_add_rating_column.sql
```

## Complete Integration Example

### Next.js + Kysely

```typescript title="lib/database.ts"
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";

export const db = new Kysely({
  dialect: new PostgresDialect({
    pool: new Pool({
      connectionString: process.env.DATABASE_URL,
    }),
  }),
});
```

```typescript title="lib/database-adapter.ts"
import { KyselyAdapter } from "@fragno-dev/db/adapters/kysely";
import { db } from "./database";

export const fragmentDbAdapter = new KyselyAdapter({
  db,
  provider: "postgresql",
});
```

```typescript title="lib/comment-fragment-server.ts"
import { createCommentFragment } from "@fragno-dev/comment-fragment";
import { fragmentDbAdapter } from "./database-adapter";

export function createCommentFragmentInstance() {
  return createCommentFragment(
    {
      maxCommentsPerPost: 100,
    },
    {
      databaseAdapter: fragmentDbAdapter,
    },
  );
}
```

```typescript title="app/api/comments/[...all]/route.ts"
import { createCommentFragmentInstance } from "@/lib/comment-fragment-server";

const commentFragment = createCommentFragmentInstance();
export const { GET, POST, PUT, PATCH, DELETE } = commentFragment.handlersFor("next-js");
```

### Remix + Drizzle

```typescript title="app/lib/database.ts"
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export const db = drizzle(pool);
```

```typescript title="app/lib/database-adapter.ts"
import { DrizzleAdapter } from "@fragno-dev/db/adapters/drizzle";
import { db } from "./database";

export const fragmentDbAdapter = new DrizzleAdapter({
  db,
  provider: "postgresql",
});
```

```typescript title="app/lib/comment-fragment-server.ts"
import { createCommentFragment } from "@fragno-dev/comment-fragment";
import { fragmentDbAdapter } from "./database-adapter";

export function createCommentFragmentInstance() {
  return createCommentFragment({}, { databaseAdapter: fragmentDbAdapter });
}
```

```typescript title="app/routes/api.comments.tsx"
import type { LoaderFunctionArgs, ActionFunctionArgs } from "@remix-run/node";
import { createCommentFragmentInstance } from "~/lib/comment-fragment-server";

export async function loader({ request }: LoaderFunctionArgs) {
  return await createCommentFragmentInstance().handler(request);
}

export async function action({ request }: ActionFunctionArgs) {
  return await createCommentFragmentInstance().handler(request);
}
```

## CI/CD Integration

### Running Migrations in Production

Add migration commands to your deployment pipeline:

```yaml title=".github/workflows/deploy.yml"
- name: Run Fragment Migrations
  run: |
    npm run build
    npx fragno-cli db migrate lib/comment-fragment-server.ts
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
```

### Migration Strategy

1. **Development**: Generate migrations locally as you add Fragments
2. **Staging**: Test migrations in staging environment
3. **Production**: Run migrations as part of deployment

<Callout title="Zero-Downtime Migrations" type="warn">
  Fragment migrations follow best practices for zero-downtime deployments: - New columns are added
  with defaults or as nullable - Old columns are deprecated before removal - Indexes are created
  concurrently when supported
</Callout>

## Multiple Fragments

You can use multiple database Fragments in the same application. Each Fragment manages its own
namespaced tables:

```typescript
import { createCommentFragment } from "@fragno-dev/comment-fragment";
import { createRatingFragment } from "@fragno-dev/rating-fragment";
import { fragmentDbAdapter } from "./database-adapter";

// Same adapter for all Fragments
const comments = createCommentFragment({}, { databaseAdapter: fragmentDbAdapter });
const ratings = createRatingFragment({}, { databaseAdapter: fragmentDbAdapter });
```

Tables are automatically namespaced:

- Comment Fragment: `fragno_comment_fragment_comment`
- Rating Fragment: `fragno_rating_fragment_rating`

## Troubleshooting

### Adapter Configuration Issues

**Problem:** `Error: Invalid provider`

**Solution:** Ensure provider matches your database:

```typescript
// PostgreSQL
new KyselyAdapter({ db, provider: "postgresql" });

// MySQL
new KyselyAdapter({ db, provider: "mysql" });

// SQLite
new KyselyAdapter({ db, provider: "sqlite" });
```

### Connection Problems

**Problem:** `Error: Failed to connect to database`

**Solution:** Verify your database connection works independently:

```typescript
// Test your Kysely/Drizzle instance
const result = await db.selectFrom("pg_database").selectAll().execute();
console.log("Database connected:", result);
```

### Migration Conflicts

**Problem:** `Migration already applied`

**Solution:** Check migration status and skip if already applied:

```bash
# View current state
npx fragno-cli db info lib/fragment-instance.ts

# Manually mark migration as applied (if needed)
# Edit the fragno_migrations table in your database
```

### Type Errors with Adapter

**Problem:** TypeScript errors when creating adapter

**Solution:** Ensure types match your ORM version:

```typescript
// Kysely - ensure correct typing
import type { Kysely } from "kysely";

const db: Kysely<any> = new Kysely({...});
const adapter = new KyselyAdapter({ db, provider: "postgresql" });
```

## FAQs

**Q: Do I need to learn a new ORM?**

A: No. You continue using your existing Kysely or Drizzle setup. The Fragment just adds its tables
to your database.

**Q: Can I query Fragment tables directly?**

A: Yes, but it's not recommended. Use the Fragment's service methods instead. Fragment table names
are implementation details that may change.

**Q: What if I don't use Kysely or Drizzle?**

A: Currently, only Kysely and Drizzle adapters are available. Support for other ORMs may be added in
the future.

**Q: How do migrations work with multiple environments?**

A: Generate migrations once in development, commit them to git, then apply the same migrations in
staging and production.

**Q: Can I customize the table name prefix?**

A: No, the prefix is automatic and ensures no conflicts. Tables are namespaced as
`fragno_{fragment-name}_{table-name}`.

## Next Steps

- Learn about [Services](./services) to understand how to use Fragment methods
- Check [Integrating a Fragment](./integrating-a-fragment) for complete integration guide
