---
title: Integrating a Fragment
description: Specifics for integration per framework.
---

import { Callout } from "fumadocs-ui/components/callout";
import { TypeTable } from "fumadocs-ui/components/type-table";

Integrating a Fragment into your project is a straightforward process. There are two main
integration points for a Fragment: server-side and client-side. This page contains
framework-specific integration details.

A complete guide to integrating a Fragment is available on the previous page:

<Cards>
  <Card
    title="User Quick Start"
    href="/docs/fragno/user-quick-start"
    description="Learn how to integrate a Fragment into your codebase."
  />
</Cards>

## Fragno Configuration

Every Fragno Fragment can be configured with several built-in options:

<TypeTable
  type={{
    baseUrl: {
      description:
        "The base URL of the Fragment. Must be changed when running the backend separately from the frontend.",
      type: "string",
      default: "/",
    },
    mountRoute: {
      description: "The mount route of the Fragment. Defaults to `/api/${fragmentName}/",
      type: "string",
      default: "/api/example-fragment",
    },
  }}
/>

These options can be configured at the frontend integration point, and are relevant when mounting
the backend route in a non-standard location.

## Fragment-specific Configuration

Most Fragments will also require some configuration specific to them. Check the documentation for
the specific Fragment you are integrating to figure out what configuration is required.

## Fragments with Databases

Some Fragments include a database layer for persistent storage. These Fragments require you to
provide a **database adapter** that connects the Fragment to your existing database.

<Callout title="Database Integration Required" type="warn">
  If a Fragment requires `FragnoPublicConfigWithDatabase` or mentions `databaseAdapter` in its
  documentation, you must set up database integration before using it.
</Callout>

Fragno’s DB adapters use **Kysely’s `Dialect` interface** as the query execution layer. This lets us
reuse Kysely’s dialect ecosystem (and keep adapter code small). When creating an adapter you must
provide:

- **`dialect`**: from `@fragno-dev/db/dialects` (or a Kysely/community dialect)
- **`driverConfig`**: from `@fragno-dev/db/drivers` (must match the database + driver you use)

### Quick Setup

1. **Install the database package:**

   ```bash
   npm install @fragno-dev/db
   ```

2. **Create an adapter (dialect + driver config):**

   ```typescript
   import { DrizzleAdapter } from "@fragno-dev/db/adapters/drizzle";
   import { PostgresDialect } from "@fragno-dev/db/dialects";
   import { NodePostgresDriverConfig } from "@fragno-dev/db/drivers";
   import { Pool } from "pg";

   const dialect = new PostgresDialect({
     pool: new Pool({ connectionString: process.env.DATABASE_URL }),
   });

   export const adapter = new DrizzleAdapter({
     dialect,
     driverConfig: new NodePostgresDriverConfig(),
   });
   ```

3. **Pass adapter when creating Fragment:**

   ```typescript
   const fragment = createCommentFragment({}, { databaseAdapter: adapter });
   ```

4. **Run migrations:**
   ```bash
   npx fragno-cli db generate lib/fragment-instance.ts
   npx fragno-cli db migrate lib/fragment-instance.ts
   ```

For complete database integration instructions, see
[Database Fragments](./database-fragments/overview).

## Reference

### Database Adapters

Available built-in dialects:

- **SQL**: `SqliteDialect`, `PostgresDialect`, `MysqlDialect` (from `@fragno-dev/db/dialects`)
- **Cloudflare Durable Objects (SQLite)**: `DurableObjectDialect` (from
  `@fragno-dev/db/dialects/durable-object`)

Available driver configs (`@fragno-dev/db/drivers`):

- **SQLite**: `BetterSQLite3DriverConfig`, `SQLocalDriverConfig`,
  `CloudflareDurableObjectsDriverConfig`
- **PostgreSQL**: `NodePostgresDriverConfig`, `PGLiteDriverConfig`
- **MySQL/MariaDB**: `MySQL2DriverConfig`

### Full-stack Frameworks

```typescript title="app/api/example-fragment/[...all]/route.ts" tab="Next.js"
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";

const exampleFragment = createExampleFragmentInstance();
export const { GET, POST, PUT, PATCH, DELETE } = exampleFragment.handlersFor("next-js");
```

```typescript title="app/routes/api/example-fragment.tsx" tab="React Router v7 / Remix"
import type { Route } from "./+types/example-fragment";
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";

export async function loader({ request }: Route.LoaderArgs) {
  return await createExampleFragmentInstance().handler(request);
}

export async function action({ request }: Route.ActionArgs) {
  return await createExampleFragmentInstance().handler(request);
}
```

```typescript title="src/pages/api/example-fragment/[...all].ts" tab="Astro"
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";

const exampleFragment = createExampleFragmentInstance();
export const { ALL } = exampleFragment.handlersFor("astro");
export const prerender = false;
```

```ts title="routes/api/example-fragment/[...path].ts" tab="SvelteKit"
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";

const exampleFragment = createExampleFragmentInstance();
export const { GET, POST, PUT, PATCH, DELETE } = exampleFragment.handlersFor("svelte-kit");
export const prerender = false;
```

```typescript title="server/api/example-fragment/[...all].ts" tab="Nuxt"
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";

export default fromWebHandler(createExampleFragmentInstance().handler);
```

```typescript title="routes/api/[...example-fragment].ts" tab="SolidStart"
import { exampleFragmentInstance } from "@/lib/example-fragment-server";

// Make sure to initialize the fragment outside of route files
export const { GET, POST, PUT, PATCH, DELETE } = exampleFragmentInstance.handlersFor("solid-start");
```

Note: in Remix, the file location might be different, as well as the `Route` type import.

### Server-side Frameworks

```typescript title="index.ts" tab="Hono"
import { Hono } from "hono";
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";

const app = new Hono();
app.all("/api/example-fragment/*", (c) => createExampleFragmentInstance().handler(c.req.raw));
```

For Node/Express, install `@fragno-dev/node` to use `toNodeHandler`.

```typescript title="server.js" tab="Express"
import express from "express";
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";
import { toNodeHandler } from "@fragno-dev/node";

const app = express();
app.all("/api/example-fragment/*", toNodeHandler(createExampleFragmentInstance().handler));

// WARNING! If you're using the Express json middleware, make sure that it's mounted AFTER the
// Fragment handler.
app.use(express.json());

app.listen(3000);
```

```typescript title="index.ts" tab="Node.js"
import { createServer } from "node:http";
import { createExampleFragmentInstance } from "@/lib/example-fragment-server";
import { toNodeHandler } from "@fragno-dev/node";

const server = createServer((req, res) => {
  const exampleFragment = createExampleFragmentInstance();

  // Only handle requests when the URL starts with the Fragment's mount route.
  if (req.url?.startsWith(exampleFragment.mountRoute)) {
    const handler = toNodeHandler(exampleFragment.handler);
    return handler(req, res);
  }

  // ... Your route handling
});
```
