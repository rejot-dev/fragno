---
title: Querying
description: Using the ORM to query and manipulate data
---

import { Callout } from "fumadocs-ui/components/callout";

The `orm` object provides a type-safe query interface for all CRUD operations. All methods are fully
typed based on your schema.

## Accessing the ORM

The `orm` is available in both `withDependencies()` and `withServices()`:

```typescript
const fragmentDef = defineFragmentWithDatabase("my-fragment")
  .withDatabase(mySchema)
  .withDependencies(({ orm }) => {
    // Use in dependencies
  })
  .withServices(({ orm, deps }) => {
    // Use in services
    return {
      createComment: async (data) => {
        return orm.create("comment", data);
      },
    };
  });
```

## Index-Based Queries

All queries in Fragno DB must specify an index using `whereIndex()`. This ensures optimal
performance and predictable query patterns.

```typescript
// Query using the primary index (ID)
const users = await orm.find("users", (b) =>
  b.whereIndex("primary", (eb) => eb("id", "=", "user123")),
);

// Query using a custom index
const users = await orm.find("users", (b) =>
  b.whereIndex("idx_email", (eb) => eb("email", "=", "user@example.com")),
);
```

<Callout title="Why Index-Based Queries?" type="info">
  Requiring indexes for all queries ensures consistent performance and prevents slow table scans.
</Callout>

## Finding Records

### Basic Queries

```typescript
// Find all users (implicitly uses primary index)
const users = await orm.find("users");

// Find with filtering
const activeUsers = await orm.find("users", (b) =>
  b.whereIndex("idx_status", (eb) => eb("status", "=", "active")),
);

// Select specific columns
const userNames = await orm.find("users", (b) => b.whereIndex("primary").select(["id", "name"]));
// Returns: Array<{ id: FragnoId; name: string }>

// Count records
const userCount = await orm.find("users", (b) => b.whereIndex("primary").selectCount());
// Returns: number
```

### Cursor-Based Pagination

Use cursor-based pagination for efficient paging through large result sets:

```typescript
import { encodeCursor } from "@fragno-dev/db";

// Fetch first page
const firstPage = await orm.find("users", (b) =>
  b.whereIndex("idx_name").orderByIndex("idx_name", "asc").pageSize(10),
);

// Create cursor from last item
const lastItem = firstPage[firstPage.length - 1];
const cursor = encodeCursor({
  indexValues: { name: lastItem.name },
  direction: "forward",
});

// Fetch next page using cursor
const nextPage = await orm.find("users", (b) =>
  b.whereIndex("idx_name").after(cursor).pageSize(10).orderByIndex("idx_name", "asc"),
);
```

<Callout title="Cursor API Ergonomics" type="warn">
  The cursor API currently requires manually building cursor objects with index values. This is not
  very ergonomic and will be improved in future versions.
</Callout>

### Ordering

Sort results using indexes:

```typescript
// Order by an index
const users = await orm.find("users", (b) =>
  b
    .whereIndex("idx_created", (eb) => eb("status", "=", "active"))
    .orderByIndex("idx_created", "desc"),
);
```

### Joins

Load related data using joins:

```typescript
// Join a single relation
const postsWithAuthor = await orm.find("posts", (b) =>
  b.whereIndex("primary").join((j) => j.author()),
);

// Access joined data
postsWithAuthor.forEach((post) => {
  console.log(post.title);
  console.log(post.author?.name); // Typed as User | null
});

// Join with filtering and selection
const posts = await orm.find("posts", (b) =>
  b
    .whereIndex("primary")
    .join((j) =>
      j.author((authorBuilder) =>
        authorBuilder
          .whereIndex("idx_status", (eb) => eb("status", "=", "active"))
          .select(["name"]),
      ),
    ),
);

// Nested joins
const commentsWithPostAndAuthor = await orm.find("comments", (b) =>
  b
    .whereIndex("primary")
    .join((j) => j.post((postBuilder) => postBuilder.join((j2) => j2.author()))),
);
```

## Creating Records

```typescript
// Create single record
const userId = await orm.create("users", {
  name: "Alice",
  email: "alice@example.com",
  age: 25,
});
// Returns: FragnoId

// Create multiple records
const userIds = await orm.createMany("users", [
  { name: "Bob", email: "bob@example.com" },
  { name: "Carol", email: "carol@example.com" },
]);
// Returns: FragnoId[]

// Columns with defaultTo$() are auto-populated
await orm.create("posts", {
  title: "My Post",
  content: "Content here",
  userId: userId.toString(),
  // createdAt auto-generated via defaultTo$("now")
});
```

## Updating Records

```typescript
// Update by ID
await orm.update("users", userId, (b) => b.set({ name: "Alice Updated", age: 26 }));
```

## Deleting Records

```typescript
// Delete by ID
await orm.delete("users", userId);
```

## Transactions (Unit of Work)

Unit of Work provides atomic transactions with a two-phase approach and optimistic concurrency
control.

### Two-Phase Transactions with Version Checking

Fragno DB automatically tracks row versions in a hidden `_version` column. The two-phase pattern
enables safe concurrent updates:

```typescript
const uow = orm.createUnitOfWork();

// Phase 1: Retrieval - fetch data with version info
uow.find("users", (b) => b.whereIndex("primary", (eb) => eb("id", "=", userId)));
uow.find("accounts", (b) => b.whereIndex("idx_user", (eb) => eb("userId", "=", userId)));

// Execute retrieval phase
const [users, accounts] = await uow.executeRetrieve();

// Phase 2: Mutation - modify data with version checks
const user = users[0];
const account = accounts[0];

// Use .check() for optimistic locking
uow.update("users", user.id, (b) => b.set({ lastLogin: new Date() }).check());
uow.update("accounts", account.id, (b) => b.set({ balance: account.balance + 100 }).check());

// Execute mutations atomically
const { success } = await uow.executeMutations();
if (!success) {
  // Version conflict - another transaction modified the data
  // Retry the entire transaction
  console.error("Concurrent modification detected");
}
```

**How `.check()` works:**

- Only succeeds if the row's `_version` hasn't changed since retrieval
- Prevents lost updates in concurrent scenarios
- Requires a `FragnoId` with version info (not a plain string)
- Returns `success: false` if any version check fails

<Callout title="Version Checking Requires FragnoId" type="warn">
  `.check()` only works with `FragnoId` objects from query results. String IDs don't contain version
  information and will throw an error.
</Callout>

### Getting Created IDs

```typescript
const uow = orm.createUnitOfWork();

uow.create("users", { name: "Alice", email: "alice@example.com" });
uow.create("users", { name: "Bob", email: "bob@example.com" });

await uow.executeMutations();

// Get IDs of created records
const createdIds = uow.getCreatedIds();
console.log(createdIds[0].toString()); // First user's ID
console.log(createdIds[1].toString()); // Second user's ID
```

## Wrapping in Services

ORM operations won't be available in services (and thus to the user) by default. You can wrap these
operations in functions as part of the services object. You're also free to expose the `orm` object
directly to the user if you want to, but make sure to think about encapsulation and security before
you do.

```typescript
.withServices(({ orm }) => {
  return {
    createComment: async (data: { content: string; userId: string; postId: string }) => {
      // Validation
      if (data.content.length < 10) {
        throw new Error("Comment too short");
      }

      // Create with business logic
      const id = await orm.create("comment", {
        content: data.content,
        userId: data.userId,
        postId: data.postId,
      });

      return { id: id.toString(), ...data };
    },

    getCommentsByPost: async (postId: string, limit = 20) => {
      return orm.find("comment", (b) =>
        b
          .whereIndex("idx_post", (eb) => eb("postId", "=", postId))
          .orderByIndex("idx_created", "desc")
          .pageSize(limit),
      );
    },
  };
})
```

## Next Steps

- Learn about [Defining Schemas](/docs/for-library-authors/database-integration/defining-schemas)
- See [Dependencies and Services](/docs/for-library-authors/features/dependencies-and-services) for
  using ORM in context
- Check the
  [example-fragments/fragno-db-library](https://github.com/rejot-dev/fragno/tree/main/example-fragments/fragno-db-library)
