---
title: "Solving Split Brain Integrations"
description: "A Stripe integration case study"
date: "2025-11-20"
author: "Jan Schutte"
image: "blog-stripe-case-study-hero.jpeg"
---

import { StripeDataFlow } from "../../components/stripe-data-flow";

# Solving Split Brain Integrations

Those who build API based products that other developers need to implement, know that it is not
always easy to get the developer experience (DX) smooth. You may spend some time educating users or
even build custom CLIs for them, and the actual implementation might be hard to get right. I believe
that DX for the implementer can greatly be improved if it were possible to offer full-stack
integration primitives that cover frontend, backend, and database thereby shifting much of the
integration work to the service provider.

An often quoted problem when integrating with third party services is the split brain problem: your
source of truth ends up divided between two systems. Most developers solve this by integrating
webhooks and maintaining a local view of the remote state. This however requires that users are
educated on the best way to integrate with that service. A smoother integration experience would be
if most of the integration code, i.e. webhook handlers, database schemas and frontend hooks, were
provided by the service provider directly.

In this case study, we explore our alternative Stripe subscription integration library (called
"fragment" in Fragno terms) that provides components for every layer of the stack and we see how it
makes integrating with Stripe significantly simpler.

## Stripe Webhooks

We're using Stripe's Billing product for subscriptions which handles payment schedules, subscription
lifecycle management and invoicing for us. The application needs to know if our customers have an
active subscription, but that information now exists in Stripe: we have split our application's
brain.

A common design pattern to solve this is by creating a view of Stripe's subscription data inside
your own database, and keep it up-to-date by integrating with Stripe's webhooks. You can listen to
subscription events and update your internal record as these updates come in. This is a solid
solution: your app has low latency and you can query the data as you see fit.

The figure below shows what that would look like. In blue we have annotated the components that we
have built in our Stripe implementation.

<figure className="flex flex-col items-center justify-center">
  <StripeDataFlow mode="with-fragment" />
  <figcaption className="max-w-prose text-center text-sm text-gray-500 dark:text-gray-400">
    A typical Stripe integration where webhook events are processed and stored in the database.
  </figcaption>
</figure>

### Hidden complexity

Implementing a few webhooks seems simple enough on the surface, but in reality always requires more
work than you'd think.

The development experience isn't great, you need to find a way to generate webhook events in your
test setup and need to set up a tunnel for Stripe to reach your dev machine. You need to deal with
duplicated events or events arriving out of order. You must validate webhook signatures to prevent
abuse, and you must ensure you can process webhooks fast enough so a sudden burst of retries from
Stripe doesn't overload your system. On top of that, Stripe has about 224 distinct events that you
_may_ or _may not_ have to integrate with.

All the details quickly pile up to become a bit of a headache. The funny thing is, it seems that
everyone using Stripe for subscriptions has to deal with the exact same set of problems. Stripe
provides only an API client, no database schemas, no backend routes, or ready-to-use frontend hooks
for using those routes.

## The missing piece

Why doesn't Stripe help you more when you're integrating with their platform? For one, they can't
make any assumptions about your tech stack: which database or SQL dialect you use, which ORM, which
backend framework, or even which programming language. Maintaining bespoke solutions across all of
these options and product features is seemingly an intractable problem.

What's missing is an abstraction that allows Stripe to distribute modular building blocks that work
across the stack. With Fragno we are trying to address this problem directly. We do have to slice
the cake one way however: we assume TypeScript for the whole stack.

With Fragno a Stripe integration looks very much like how you'd implement it yourself, but what's
different is _who_ is implementing it.

This way much of the headache of implementing Stripe shifts from the customer to the fragment
provider. It would be preferable to have Stripe maintain this fragment of course, updating it as
they change their APIs and data model, but for now we have taken on this task ourselves.

## What the integration looks like

Let's walk through a few code samples to illustrate the practical differences for a developer when
using a fragment to build a Stripe integration.

Detailed installation instructions are in our [quickstart guide](/docs/stripe/quickstart).

### Server

For the server, we need to configure secrets and hook up the database using one of
[the supported adapters](/docs/fragno/reference/frameworks#database-adapters).

```typescript title="stripe.ts"
import { createStripeFragment } from "@fragno-dev/stripe";
import { DrizzleAdapter } from "@fragno-dev/db/adapters/drizzle";

const stripeFragment = createStripeFragment(
  {
    stripeSecretKey: process.env.STRIPE_SECRET_KEY,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
    /* other configs */
  },
  {
    databaseAdapter: new DrizzleAdapter({ db, provider: "postgresql" }),
  },
);
```

Then the API route handlers must be mounted in the application, note that this also includes the
endpoint for processing webhook events.

<include>../.includes/stripe/mount-routes.md</include>

### Database

With the backend configured, it's time to generate the table schema for our subscriptions. The
Fragno CLI reads which fragments you've configured and generates schema files for the ORM and
database of choice. In this example we're using Drizzle with PostgreSQL.

```npm
npx fragno-cli db generate stripe.ts -o stripe.schema.ts
```

```typescript title="stripe.schema.ts"
import { pgTable, varchar, text } from "drizzle-orm/pg-core";
import { createId } from "@fragno-dev/db/id";

export const subscription_stripe = pgTable(
  "subscription_stripe",
  {
    id: varchar("id", { length: 30 })
      .notNull()
      .$defaultFn(() => createId()),
    referenceId: text("referenceId"),
    /* etc */
  },
  (table) => [index("idx_reference_id_stripe").on(table.referenceId)],
);
```

After the schema file is generated, you can create a migration for the new schema just like you
would do for any other schema change.

### Linking the data model

From a data model perspective, a subscription must be owned by some kind of entity, like a user or
organization, and this mapping is one of the few things that remains to be implemented by the
developer. It basically amounts to a `stripe_customer_id` column on the user table. The fragment
requires you to implement a callback that sets this value when Stripe Customers are created.

Similarly, when one of your end-users interacts with the `/api/stripe/upgrade` or
`/api/stripe/cancel` routes, that request must be authenticated and resolved back to a Stripe
Customer that belongs to that user (if one exists). This is another callback the developer must
implement.

### Frontend

This one is easy enough; simply import your framework-specific client:

<include>../.includes/stripe/create-client.md</include>

Now you can start building components using this client:

```typescript title="plan-switcher.tsx"
import { stripeClient } from "stripe-client.ts";

/* ... */

const { mutate: upgrade, loading, error } = stripeClient.upgradeSubscription();

const handleSwitchPlan = async (plan: Plan) => {
  const response = await upgrade({
    body: {
      priceId: plan.priceId, // Stripe Price ID
      successUrl: window.location.href,
      cancelUrl: window.location.href,
      quantity: 1,
    },
  });
  if (response?.redirect) {
    // Redirects to Stripe Checkout Session for collecting payment information
    window.location.href = response.url;
  }
};
```

## What's the Difference

Note that this new way of integrating is more configuration-based rather than implementation-based.
Instead of writing route handlers and designing database schemas, you're primarily connecting
pre-built components to each layer of the stack.

In the end, the cognitive load for the developer is mostly spent on the parts that are unique to
their application: the data model. Answering the question of, how does a Stripe subscription relate
to the entities in my system? Many of the peculiarities of implementing Stripe have become the
fragment author's problem, this way the developer can focus on the product they're building.

## Try it yourself

Fragno and the Stripe fragment are very much in a developer preview state, if you're interested in
trying it out take a look at our [quickstart guide](/docs/stripe/quickstart). Code is available on
[GitHub](https://github.com/rejot-dev/fragno) under the MIT license.

If you're interested in building better SDKs for your users, we'd love to
[discuss](https://rejot.dev/contact) what you might need.

## Attribution

I'd like to thank the authors of the following resources for helping inspire this case study.

- Theo Browne:
  ["How I Stay Sane Implementing Stripe"](https://github.com/t3dotgg/stripe-recommendations)
- Better-auth: [Stripe plugin](https://www.better-auth.com/docs/plugins/stripe)
