{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-builder",
  "type": "registry:component",
  "title": "Form Builder",
  "description": "A visual form builder that generates JSON Schema and JSONForms UI Schema. Build forms with support for text, number, email, boolean, date, time, datetime, and dropdown fields.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "card",
    "input",
    "label",
    "select",
    "switch",
    "tooltip",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "components/ui/form-builder/types.ts",
      "type": "registry:component",
      "content": "/**\n * Field types supported by the form builder.\n * Maps to JSON Schema types and formats.\n */\nexport type FieldType =\n  | \"text\"\n  | \"textarea\"\n  | \"number\"\n  | \"integer\"\n  | \"slider\"\n  | \"email\"\n  | \"boolean\"\n  | \"date\"\n  | \"time\"\n  | \"datetime\"\n  | \"select\";\n\n/**\n * Type-specific configuration options for a field.\n */\nexport interface FieldOptions {\n  /** Options for select/dropdown fields */\n  enumValues?: string[];\n  /** Minimum value for number/integer fields */\n  minimum?: number;\n  /** Maximum value for number/integer fields */\n  maximum?: number;\n  /** Placeholder text for text/textarea fields */\n  placeholder?: string;\n}\n\n/**\n * Represents a single field in the form builder.\n */\nexport interface FormField {\n  /** Unique identifier for this field */\n  id: string;\n  /** Property name in the generated JSON Schema */\n  fieldName: string;\n  /** Display label for the field */\n  label: string;\n  /** Optional help text / description */\n  description?: string;\n  /** The type of field */\n  fieldType: FieldType;\n  /** Whether the field is required */\n  required: boolean;\n  /** Type-specific options */\n  options?: FieldOptions;\n}\n\n/**\n * State of the form builder.\n */\nexport interface FormBuilderState {\n  fields: FormField[];\n}\n\n/**\n * JSON Schema property definition (subset of JSON Schema).\n */\nexport interface JsonSchemaProperty {\n  type: \"string\" | \"number\" | \"integer\" | \"boolean\" | \"object\" | \"array\";\n  title?: string;\n  description?: string;\n  format?: string;\n  enum?: string[];\n  minimum?: number;\n  maximum?: number;\n  default?: unknown;\n}\n\n/**\n * JSON Schema for the form data.\n */\nexport interface DataSchema {\n  type: \"object\";\n  properties: Record<string, JsonSchemaProperty>;\n  required?: string[];\n}\n\n/**\n * UI Schema element (Control or Layout).\n */\nexport interface UiSchemaElement {\n  type: \"Control\" | \"VerticalLayout\" | \"HorizontalLayout\" | \"Group\";\n  scope?: string;\n  elements?: UiSchemaElement[];\n  options?: Record<string, unknown>;\n}\n\n/**\n * Generated schemas from the form builder.\n */\nexport interface GeneratedSchemas {\n  dataSchema: DataSchema;\n  uiSchema: UiSchemaElement;\n}\n"
    },
    {
      "path": "components/ui/form-builder/constants.ts",
      "type": "registry:component",
      "content": "import {\n  Type,\n  AlignLeft,\n  Hash,\n  SlidersHorizontal,\n  Mail,\n  CheckSquare,\n  Calendar,\n  Clock,\n  CalendarClock,\n  List,\n} from \"lucide-react\";\nimport type { FieldType, FieldOptions } from \"./types\";\n\n/**\n * Configuration for a field type in the form builder.\n */\nexport interface FieldTypeConfig {\n  type: FieldType;\n  label: string;\n  icon: React.ComponentType<{ className?: string }>;\n  description: string;\n  defaultOptions?: FieldOptions;\n}\n\n/**\n * All supported field types with their metadata.\n */\nexport const FIELD_TYPES: FieldTypeConfig[] = [\n  {\n    type: \"text\",\n    label: \"Short Text\",\n    icon: Type,\n    description: \"Single line text input\",\n  },\n  {\n    type: \"textarea\",\n    label: \"Long Text\",\n    icon: AlignLeft,\n    description: \"Multi-line text area\",\n  },\n  {\n    type: \"number\",\n    label: \"Decimal number\",\n    icon: Hash,\n    description: \"Allows decimal values\",\n  },\n  {\n    type: \"integer\",\n    label: \"Whole number\",\n    icon: Hash,\n    description: \"Only whole numbers\",\n  },\n  {\n    type: \"slider\",\n    label: \"Slider\",\n    icon: SlidersHorizontal,\n    description: \"Numeric slider input\",\n    defaultOptions: {\n      minimum: 1,\n      maximum: 10,\n    },\n  },\n  {\n    type: \"email\",\n    label: \"Email\",\n    icon: Mail,\n    description: \"Email address with validation\",\n  },\n  {\n    type: \"boolean\",\n    label: \"Checkbox\",\n    icon: CheckSquare,\n    description: \"Yes/No toggle\",\n  },\n  {\n    type: \"date\",\n    label: \"Date\",\n    icon: Calendar,\n    description: \"Date picker\",\n  },\n  {\n    type: \"time\",\n    label: \"Time\",\n    icon: Clock,\n    description: \"Time picker\",\n  },\n  {\n    type: \"datetime\",\n    label: \"Date & Time\",\n    icon: CalendarClock,\n    description: \"Date and time picker\",\n  },\n  {\n    type: \"select\",\n    label: \"Dropdown\",\n    icon: List,\n    description: \"Select from options\",\n    defaultOptions: {\n      enumValues: [\"Option 1\", \"Option 2\", \"Option 3\"],\n    },\n  },\n];\n\n/**\n * Get the configuration for a specific field type.\n */\nexport function getFieldTypeConfig(type: FieldType): FieldTypeConfig | undefined {\n  return FIELD_TYPES.find((config) => config.type === type);\n}\n"
    },
    {
      "path": "components/ui/form-builder/schema-generator.ts",
      "type": "registry:component",
      "content": "import type {\n  FormField,\n  FormBuilderState,\n  GeneratedSchemas,\n  JsonSchemaProperty,\n  UiSchemaElement,\n  DataSchema,\n} from \"./types\";\n\n/**\n * Converts a single field to its JSON Schema property definition.\n */\nexport function fieldToSchemaProperty(field: FormField): JsonSchemaProperty {\n  const base: JsonSchemaProperty = {\n    type: \"string\",\n    title: field.label,\n  };\n\n  if (field.description) {\n    base.description = field.description;\n  }\n\n  switch (field.fieldType) {\n    case \"text\":\n      return { ...base, type: \"string\" };\n\n    case \"textarea\":\n      return { ...base, type: \"string\" };\n\n    case \"number\":\n      return {\n        ...base,\n        type: \"number\",\n        ...(field.options?.minimum !== undefined && { minimum: field.options.minimum }),\n        ...(field.options?.maximum !== undefined && { maximum: field.options.maximum }),\n      };\n\n    case \"integer\":\n      return {\n        ...base,\n        type: \"integer\",\n        ...(field.options?.minimum !== undefined && { minimum: field.options.minimum }),\n        ...(field.options?.maximum !== undefined && { maximum: field.options.maximum }),\n      };\n\n    case \"slider\": {\n      const min = field.options?.minimum;\n      const max = field.options?.maximum;\n      return {\n        ...base,\n        type: \"number\",\n        minimum: min,\n        maximum: max,\n        default: min,\n      };\n    }\n\n    case \"email\":\n      return { ...base, type: \"string\", format: \"email\" };\n\n    case \"boolean\":\n      return { ...base, type: \"boolean\" };\n\n    case \"date\":\n      return { ...base, type: \"string\", format: \"date\" };\n\n    case \"time\":\n      return { ...base, type: \"string\", format: \"time\" };\n\n    case \"datetime\":\n      return { ...base, type: \"string\", format: \"date-time\" };\n\n    case \"select\":\n      return {\n        ...base,\n        type: \"string\",\n        enum: field.options?.enumValues ?? [],\n      };\n\n    default:\n      return base;\n  }\n}\n\n/**\n * Converts a single field to its UI Schema control element.\n */\nexport function fieldToUiSchemaElement(field: FormField): UiSchemaElement {\n  const control: UiSchemaElement = {\n    type: \"Control\",\n    scope: `#/properties/${field.fieldName}`,\n  };\n\n  // Add type-specific UI options\n  const options: Record<string, unknown> = {};\n\n  if (field.fieldType === \"textarea\") {\n    options.multi = true;\n  }\n\n  if (field.fieldType === \"slider\") {\n    options.slider = true;\n  }\n\n  if (field.options?.placeholder) {\n    options.placeholder = field.options.placeholder;\n  }\n\n  if (Object.keys(options).length > 0) {\n    control.options = options;\n  }\n\n  return control;\n}\n\n/**\n * Generates JSON Schema and UI Schema from form builder state.\n */\nexport function generateSchemas(state: FormBuilderState): GeneratedSchemas {\n  const properties: Record<string, JsonSchemaProperty> = {};\n  const required: string[] = [];\n  const uiElements: UiSchemaElement[] = [];\n\n  for (const field of state.fields) {\n    // Skip fields without a valid field name\n    if (!field.fieldName) {\n      continue;\n    }\n\n    properties[field.fieldName] = fieldToSchemaProperty(field);\n\n    if (field.required) {\n      required.push(field.fieldName);\n    }\n\n    uiElements.push(fieldToUiSchemaElement(field));\n  }\n\n  const dataSchema: DataSchema = {\n    type: \"object\",\n    properties,\n    ...(required.length > 0 && { required }),\n  };\n\n  const uiSchema: UiSchemaElement = {\n    type: \"VerticalLayout\",\n    elements: uiElements,\n  };\n\n  return { dataSchema, uiSchema };\n}\n\n/**\n * Generates a valid field name from a label.\n * Converts to lowercase, replaces non-alphanumeric with underscore.\n */\nexport function labelToFieldName(label: string): string {\n  return (\n    label\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, \"_\") // Replace non-alphanumeric with underscore\n      .replace(/^_+|_+$/g, \"\") // Trim leading/trailing underscores\n      .replace(/_+/g, \"_\") || // Collapse multiple underscores\n    \"field\"\n  );\n}\n\n/**\n * Ensures a field name is unique within the form.\n * Appends a number suffix if the name already exists.\n */\nexport function ensureUniqueFieldName(baseName: string, existingNames: string[]): string {\n  let name = baseName;\n  let counter = 1;\n\n  while (existingNames.includes(name)) {\n    name = `${baseName}_${counter}`;\n    counter++;\n  }\n\n  return name;\n}\n"
    },
    {
      "path": "components/ui/form-builder/use-form-builder.ts",
      "type": "registry:component",
      "content": "import { useState, useCallback, useMemo } from \"react\";\nimport type { FormField, FormBuilderState, FieldType, GeneratedSchemas } from \"./types\";\nimport { generateSchemas, labelToFieldName, ensureUniqueFieldName } from \"./schema-generator\";\nimport { getFieldTypeConfig } from \"./constants\";\n\n/**\n * Generates a unique ID for a field.\n */\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\n/**\n * Hook for managing form builder state.\n */\nexport interface UseFormBuilderOptions {\n  initialState?: Partial<FormBuilderState>;\n  onChange?: (schemas: GeneratedSchemas) => void;\n}\n\nexport function useFormBuilder(options: UseFormBuilderOptions = {}) {\n  const { initialState, onChange } = options;\n  const [state, setState] = useState<FormBuilderState>({\n    fields: initialState?.fields ?? [],\n  });\n\n  // Helper to update state and notify parent - both calls batched by React\n  const updateState = useCallback(\n    (nextState: FormBuilderState) => {\n      setState(nextState);\n      onChange?.(generateSchemas(nextState));\n    },\n    [onChange],\n  );\n\n  const existingFieldNames = useMemo(() => state.fields.map((f) => f.fieldName), [state.fields]);\n\n  const addField = useCallback(\n    (fieldType: FieldType = \"text\") => {\n      const typeConfig = getFieldTypeConfig(fieldType);\n      const label = \"Untitled Field\";\n      const fieldName = ensureUniqueFieldName(labelToFieldName(label), existingFieldNames);\n\n      const newField: FormField = {\n        id: generateId(),\n        fieldName,\n        label,\n        fieldType,\n        required: false,\n        options: typeConfig?.defaultOptions ? { ...typeConfig.defaultOptions } : undefined,\n      };\n\n      updateState({\n        ...state,\n        fields: [...state.fields, newField],\n      });\n\n      return newField.id;\n    },\n    [state, existingFieldNames, updateState],\n  );\n\n  const updateField = useCallback(\n    (id: string, updates: Partial<Omit<FormField, \"id\">>) => {\n      updateState({\n        ...state,\n        fields: state.fields.map((field) => (field.id === id ? { ...field, ...updates } : field)),\n      });\n    },\n    [state, updateState],\n  );\n\n  const deleteField = useCallback(\n    (id: string) => {\n      updateState({\n        ...state,\n        fields: state.fields.filter((field) => field.id !== id),\n      });\n    },\n    [state, updateState],\n  );\n\n  const moveField = useCallback(\n    (fromIndex: number, toIndex: number) => {\n      const fields = [...state.fields];\n      const [removed] = fields.splice(fromIndex, 1);\n      fields.splice(toIndex, 0, removed);\n      updateState({ ...state, fields });\n    },\n    [state, updateState],\n  );\n\n  const duplicateField = useCallback(\n    (id: string) => {\n      const field = state.fields.find((f) => f.id === id);\n      if (!field) {\n        return;\n      }\n\n      const newFieldName = ensureUniqueFieldName(field.fieldName, existingFieldNames);\n\n      const newField: FormField = {\n        ...field,\n        id: generateId(),\n        fieldName: newFieldName,\n        label: `${field.label} (copy)`,\n        options: field.options ? { ...field.options } : undefined,\n      };\n\n      const index = state.fields.findIndex((f) => f.id === id);\n      const fields = [...state.fields];\n      fields.splice(index + 1, 0, newField);\n      updateState({ ...state, fields });\n\n      return newField.id;\n    },\n    [state, existingFieldNames, updateState],\n  );\n\n  /**\n   * Updates the field name based on the label, ensuring uniqueness.\n   */\n  const updateFieldNameFromLabel = useCallback(\n    (id: string, label: string) => {\n      const otherFieldNames = state.fields.filter((f) => f.id !== id).map((f) => f.fieldName);\n\n      const baseName = labelToFieldName(label);\n      const fieldName = ensureUniqueFieldName(baseName, otherFieldNames);\n\n      updateState({\n        ...state,\n        fields: state.fields.map((field) =>\n          field.id === id ? { ...field, label, fieldName } : field,\n        ),\n      });\n    },\n    [state, updateState],\n  );\n\n  const schemas: GeneratedSchemas = useMemo(() => generateSchemas(state), [state]);\n\n  return {\n    state,\n    schemas,\n    addField,\n    updateField,\n    deleteField,\n    moveField,\n    duplicateField,\n    updateFieldNameFromLabel,\n  };\n}\n"
    },
    {
      "path": "components/ui/form-builder/field-type-selector.tsx",
      "type": "registry:component",
      "content": "import {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { FIELD_TYPES } from \"./constants\";\nimport type { FieldType } from \"./types\";\n\nexport interface FieldTypeSelectorProps {\n  value: FieldType;\n  onChange: (type: FieldType) => void;\n}\n\nexport function FieldTypeSelector({ value, onChange }: FieldTypeSelectorProps) {\n  return (\n    // Cast is safe: select options are constrained to FieldType values\n    <Select value={value} onValueChange={(v) => onChange(v as FieldType)}>\n      <SelectTrigger data-slot=\"field-type-selector\" className=\"w-[180px]\">\n        <SelectValue placeholder=\"Select type\" />\n      </SelectTrigger>\n      <SelectContent>\n        {FIELD_TYPES.map((fieldType) => {\n          const Icon = fieldType.icon;\n          return (\n            <SelectItem key={fieldType.type} value={fieldType.type}>\n              <span className=\"flex items-center gap-2\">\n                <Icon className=\"text-muted-foreground size-4\" />\n                <span>{fieldType.label}</span>\n              </span>\n            </SelectItem>\n          );\n        })}\n      </SelectContent>\n    </Select>\n  );\n}\n"
    },
    {
      "path": "components/ui/form-builder/enum-values-editor.tsx",
      "type": "registry:component",
      "content": "import { Plus, Trash2, ChevronUp, ChevronDown } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface EnumValuesEditorProps {\n  values: string[];\n  onChange: (values: string[]) => void;\n  className?: string;\n}\n\nexport function EnumValuesEditor({ values, onChange, className }: EnumValuesEditorProps) {\n  const addOption = () => {\n    onChange([...values, `Option ${values.length + 1}`]);\n  };\n\n  const updateOption = (index: number, value: string) => {\n    const newValues = [...values];\n    newValues[index] = value;\n    onChange(newValues);\n  };\n\n  const deleteOption = (index: number) => {\n    onChange(values.filter((_, i) => i !== index));\n  };\n\n  const moveOption = (fromIndex: number, toIndex: number) => {\n    if (toIndex < 0 || toIndex >= values.length) {\n      return;\n    }\n    const newValues = [...values];\n    const [removed] = newValues.splice(fromIndex, 1);\n    newValues.splice(toIndex, 0, removed);\n    onChange(newValues);\n  };\n\n  return (\n    <div data-slot=\"enum-values-editor\" className={cn(\"space-y-2\", className)}>\n      <div className=\"text-muted-foreground text-sm font-medium\">Options</div>\n      <div className=\"space-y-2\">\n        {values.map((value, index) => (\n          <div key={index} className=\"flex items-center gap-2\">\n            <span className=\"text-muted-foreground w-4 text-xs\">{index + 1}.</span>\n            <Input\n              value={value}\n              onChange={(e) => updateOption(index, e.target.value)}\n              placeholder={`Option ${index + 1}`}\n              className=\"flex-1\"\n            />\n            <div className=\"flex gap-1\">\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"size-8\"\n                onClick={() => moveOption(index, index - 1)}\n                disabled={index === 0}\n              >\n                <ChevronUp className=\"size-4\" />\n                <span className=\"sr-only\">Move up</span>\n              </Button>\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"size-8\"\n                onClick={() => moveOption(index, index + 1)}\n                disabled={index === values.length - 1}\n              >\n                <ChevronDown className=\"size-4\" />\n                <span className=\"sr-only\">Move down</span>\n              </Button>\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"text-destructive hover:text-destructive size-8\"\n                onClick={() => deleteOption(index)}\n                disabled={values.length <= 1}\n              >\n                <Trash2 className=\"size-4\" />\n                <span className=\"sr-only\">Delete option</span>\n              </Button>\n            </div>\n          </div>\n        ))}\n      </div>\n      <Button type=\"button\" variant=\"outline\" size=\"sm\" onClick={addOption} className=\"w-full\">\n        <Plus className=\"mr-2 size-4\" />\n        Add Option\n      </Button>\n    </div>\n  );\n}\n"
    },
    {
      "path": "components/ui/form-builder/field-options.tsx",
      "type": "registry:component",
      "content": "import { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { EnumValuesEditor } from \"./enum-values-editor\";\nimport { getFieldTypeConfig } from \"./constants\";\nimport type { FieldType, FieldOptions as FieldOptionsType } from \"./types\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface FieldOptionsProps {\n  fieldType: FieldType;\n  options: FieldOptionsType | undefined;\n  onChange: (options: FieldOptionsType) => void;\n  className?: string;\n}\n\nexport function FieldOptions({ fieldType, options, onChange, className }: FieldOptionsProps) {\n  const updateOption = <K extends keyof FieldOptionsType>(key: K, value: FieldOptionsType[K]) => {\n    onChange({ ...options, [key]: value });\n  };\n\n  // Select field: show enum values editor\n  if (fieldType === \"select\") {\n    return (\n      <div data-slot=\"field-options\" className={cn(\"border-t pt-4\", className)}>\n        <EnumValuesEditor\n          values={options?.enumValues ?? [\"Option 1\"]}\n          onChange={(enumValues) => updateOption(\"enumValues\", enumValues)}\n        />\n      </div>\n    );\n  }\n\n  // Slider fields: show min/max (required)\n  if (fieldType === \"slider\") {\n    const defaults = getFieldTypeConfig(\"slider\")?.defaultOptions;\n    const defaultMin = defaults?.minimum ?? 1;\n    const defaultMax = defaults?.maximum ?? 10;\n    return (\n      <div data-slot=\"field-options\" className={cn(\"border-t pt-4\", className)}>\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"min-value\" className=\"text-muted-foreground text-sm\">\n              Minimum\n            </Label>\n            <Input\n              id=\"min-value\"\n              type=\"number\"\n              value={options?.minimum ?? defaultMin}\n              onChange={(e) => updateOption(\"minimum\", Number(e.target.value) || defaultMin)}\n            />\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"max-value\" className=\"text-muted-foreground text-sm\">\n              Maximum\n            </Label>\n            <Input\n              id=\"max-value\"\n              type=\"number\"\n              value={options?.maximum ?? defaultMax}\n              onChange={(e) => updateOption(\"maximum\", Number(e.target.value) || defaultMax)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  // Number/Integer fields: show min/max (optional)\n  if (fieldType === \"number\" || fieldType === \"integer\") {\n    return (\n      <div data-slot=\"field-options\" className={cn(\"border-t pt-4\", className)}>\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"min-value\" className=\"text-muted-foreground text-sm\">\n              Minimum\n            </Label>\n            <Input\n              id=\"min-value\"\n              type=\"number\"\n              placeholder=\"No minimum\"\n              value={options?.minimum ?? \"\"}\n              onChange={(e) =>\n                updateOption(\"minimum\", e.target.value ? Number(e.target.value) : undefined)\n              }\n            />\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"max-value\" className=\"text-muted-foreground text-sm\">\n              Maximum\n            </Label>\n            <Input\n              id=\"max-value\"\n              type=\"number\"\n              placeholder=\"No maximum\"\n              value={options?.maximum ?? \"\"}\n              onChange={(e) =>\n                updateOption(\"maximum\", e.target.value ? Number(e.target.value) : undefined)\n              }\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  // Text/Textarea fields: show placeholder\n  if (fieldType === \"text\" || fieldType === \"textarea\") {\n    return (\n      <div data-slot=\"field-options\" className={cn(\"border-t pt-4\", className)}>\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"placeholder\" className=\"text-muted-foreground text-sm\">\n            Placeholder\n          </Label>\n          <Input\n            id=\"placeholder\"\n            placeholder=\"Enter placeholder text\"\n            value={options?.placeholder ?? \"\"}\n            onChange={(e) => updateOption(\"placeholder\", e.target.value || undefined)}\n          />\n        </div>\n      </div>\n    );\n  }\n\n  // No options for other field types\n  return null;\n}\n"
    },
    {
      "path": "components/ui/form-builder/field-card.tsx",
      "type": "registry:component",
      "content": "import { ChevronUp, ChevronDown, Copy, Trash2 } from \"lucide-react\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Button } from \"@/components/ui/button\";\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"@/components/ui/tooltip\";\nimport { FieldTypeSelector } from \"./field-type-selector\";\nimport { FieldOptions } from \"./field-options\";\nimport { getFieldTypeConfig } from \"./constants\";\nimport type { FormField, FieldType } from \"./types\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface FieldCardProps {\n  field: FormField;\n  index: number;\n  totalCount: number;\n  onUpdate: (updates: Partial<Omit<FormField, \"id\">>) => void;\n  onUpdateLabel: (label: string) => void;\n  onDelete: () => void;\n  onDuplicate: () => void;\n  onMoveUp?: () => void;\n  onMoveDown?: () => void;\n  className?: string;\n}\n\nexport function FieldCard({\n  field,\n  index,\n  totalCount,\n  onUpdate,\n  onUpdateLabel,\n  onDelete,\n  onDuplicate,\n  onMoveUp,\n  onMoveDown,\n  className,\n}: FieldCardProps) {\n  const handleTypeChange = (fieldType: FieldType) => {\n    const typeConfig = getFieldTypeConfig(fieldType);\n    onUpdate({\n      fieldType,\n      options: typeConfig?.defaultOptions ? { ...typeConfig.defaultOptions } : undefined,\n    });\n  };\n\n  return (\n    <Card data-slot=\"field-card\" className={cn(\"relative\", className)}>\n      <CardContent className=\"pt-6\">\n        {/* Field number badge */}\n        <div className=\"bg-background text-muted-foreground absolute -top-3 left-4 px-2 text-xs font-medium\">\n          Field {index + 1}\n        </div>\n\n        {/* Main content */}\n        <div className=\"space-y-4\">\n          {/* Top row: Label + Type */}\n          <div className=\"flex flex-col gap-4 sm:flex-row\">\n            <div className=\"flex-1 space-y-2\">\n              <Label htmlFor={`field-label-${field.id}`}>Label</Label>\n              <Input\n                id={`field-label-${field.id}`}\n                value={field.label}\n                onChange={(e) => onUpdateLabel(e.target.value)}\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <Label>Type</Label>\n              <FieldTypeSelector value={field.fieldType} onChange={handleTypeChange} />\n            </div>\n          </div>\n\n          {/* Description */}\n          <div className=\"space-y-2\">\n            <Label htmlFor={`field-description-${field.id}`}>\n              Description <span className=\"text-muted-foreground font-normal\">(optional)</span>\n            </Label>\n            <Input\n              id={`field-description-${field.id}`}\n              value={field.description ?? \"\"}\n              onChange={(e) => onUpdate({ description: e.target.value || undefined })}\n            />\n          </div>\n\n          {/* Required toggle */}\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-2\">\n              <Switch\n                id={`field-required-${field.id}`}\n                checked={field.required}\n                onCheckedChange={(checked) => onUpdate({ required: checked })}\n              />\n              <Label htmlFor={`field-required-${field.id}`} className=\"cursor-pointer\">\n                Required\n              </Label>\n            </div>\n\n            {/* Action buttons */}\n            <TooltipProvider>\n              <div className=\"flex items-center gap-1\">\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"size-8\"\n                      onClick={onMoveUp}\n                      disabled={!onMoveUp}\n                    >\n                      <ChevronUp className=\"size-4\" />\n                      <span className=\"sr-only\">Move up</span>\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent>Move up</TooltipContent>\n                </Tooltip>\n\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"size-8\"\n                      onClick={onMoveDown}\n                      disabled={!onMoveDown}\n                    >\n                      <ChevronDown className=\"size-4\" />\n                      <span className=\"sr-only\">Move down</span>\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent>Move down</TooltipContent>\n                </Tooltip>\n\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"size-8\"\n                      onClick={onDuplicate}\n                    >\n                      <Copy className=\"size-4\" />\n                      <span className=\"sr-only\">Duplicate</span>\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent>Duplicate</TooltipContent>\n                </Tooltip>\n\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"text-destructive hover:text-destructive size-8\"\n                      onClick={onDelete}\n                      disabled={totalCount <= 1}\n                    >\n                      <Trash2 className=\"size-4\" />\n                      <span className=\"sr-only\">Delete</span>\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent>Delete</TooltipContent>\n                </Tooltip>\n              </div>\n            </TooltipProvider>\n          </div>\n\n          {/* Type-specific options */}\n          <FieldOptions\n            fieldType={field.fieldType}\n            options={field.options}\n            onChange={(options) => onUpdate({ options })}\n          />\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n"
    },
    {
      "path": "components/ui/form-builder/form-builder.tsx",
      "type": "registry:component",
      "content": "import { Plus } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { FieldCard } from \"./field-card\";\nimport { useFormBuilder } from \"./use-form-builder\";\nimport type { FormBuilderState, GeneratedSchemas, FieldType } from \"./types\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface FormBuilderProps {\n  /** Initial state for the form builder */\n  defaultValue?: FormBuilderState;\n  /** Callback when schemas change */\n  onChange?: (schemas: GeneratedSchemas) => void;\n  /** Additional class name */\n  className?: string;\n}\n\nexport function FormBuilder({ defaultValue, onChange, className }: FormBuilderProps) {\n  const {\n    state,\n    addField,\n    updateField,\n    deleteField,\n    moveField,\n    duplicateField,\n    updateFieldNameFromLabel,\n  } = useFormBuilder({ initialState: defaultValue, onChange });\n\n  const handleAddField = (fieldType?: FieldType) => {\n    addField(fieldType);\n  };\n\n  return (\n    <div data-slot=\"form-builder\" className={cn(\"space-y-4\", className)}>\n      {/* Field list */}\n      {state.fields.length === 0 ? (\n        <div className=\"rounded-lg border border-dashed p-8 text-center\">\n          <p className=\"text-muted-foreground\">\n            No fields yet. Add your first field to get started.\n          </p>\n        </div>\n      ) : (\n        <div className=\"space-y-4\">\n          {state.fields.map((field, index) => (\n            <FieldCard\n              key={field.id}\n              field={field}\n              index={index}\n              totalCount={state.fields.length}\n              onUpdate={(updates) => updateField(field.id, updates)}\n              onUpdateLabel={(label) => updateFieldNameFromLabel(field.id, label)}\n              onDelete={() => deleteField(field.id)}\n              onDuplicate={() => duplicateField(field.id)}\n              onMoveUp={index > 0 ? () => moveField(index, index - 1) : undefined}\n              onMoveDown={\n                index < state.fields.length - 1 ? () => moveField(index, index + 1) : undefined\n              }\n            />\n          ))}\n        </div>\n      )}\n\n      {/* Add field button */}\n      <Button type=\"button\" variant=\"outline\" className=\"w-full\" onClick={() => handleAddField()}>\n        <Plus className=\"mr-2 size-4\" />\n        Add Field\n      </Button>\n    </div>\n  );\n}\n"
    },
    {
      "path": "components/ui/form-builder/form-metadata.tsx",
      "type": "registry:component",
      "content": "import { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { cn } from \"@/lib/utils\";\n\nexport type FormStatus = \"draft\" | \"open\" | \"closed\";\n\nexport interface FormMetadata {\n  title: string;\n  description: string;\n  status: FormStatus;\n}\n\nexport interface FormMetadataEditorProps {\n  value: FormMetadata;\n  onChange: (metadata: FormMetadata) => void;\n  className?: string;\n}\n\nconst STATUS_OPTIONS: { value: FormStatus; label: string; description: string }[] = [\n  { value: \"draft\", label: \"Draft\", description: \"Not accepting submissions\" },\n  { value: \"open\", label: \"Open\", description: \"Accepting submissions\" },\n  { value: \"closed\", label: \"Closed\", description: \"No longer accepting submissions\" },\n];\n\nexport function FormMetadataEditor({ value, onChange, className }: FormMetadataEditorProps) {\n  const updateField = <K extends keyof FormMetadata>(key: K, fieldValue: FormMetadata[K]) => {\n    onChange({ ...value, [key]: fieldValue });\n  };\n\n  return (\n    <div data-slot=\"form-metadata-editor\" className={cn(\"space-y-4\", className)}>\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"form-title\">Form Title</Label>\n        <Input\n          id=\"form-title\"\n          value={value.title}\n          onChange={(e) => updateField(\"title\", e.target.value)}\n        />\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"form-description\">\n          Description <span className=\"text-muted-foreground font-normal\">(optional)</span>\n        </Label>\n        <Input\n          id=\"form-description\"\n          value={value.description}\n          onChange={(e) => updateField(\"description\", e.target.value)}\n        />\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"form-status\">Status</Label>\n        {/* Cast is safe: select options are constrained to FormStatus values */}\n        <Select value={value.status} onValueChange={(v) => updateField(\"status\", v as FormStatus)}>\n          <SelectTrigger id=\"form-status\">\n            <SelectValue placeholder=\"Select status\" />\n          </SelectTrigger>\n          <SelectContent>\n            {STATUS_OPTIONS.map((option) => (\n              <SelectItem key={option.value} value={option.value}>\n                {option.label}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n    </div>\n  );\n}\n"
    },
    {
      "path": "components/ui/form-builder/index.ts",
      "type": "registry:component",
      "content": "// Main component\nexport { FormBuilder } from \"./form-builder\";\nexport type { FormBuilderProps } from \"./form-builder\";\n\n// Types\nexport type {\n  FieldType,\n  FieldOptions as FieldOptionsType,\n  FormField,\n  FormBuilderState,\n  GeneratedSchemas,\n  DataSchema,\n  UiSchemaElement,\n  JsonSchemaProperty,\n} from \"./types\";\n\n// Schema generation utilities\nexport {\n  generateSchemas,\n  fieldToSchemaProperty,\n  fieldToUiSchemaElement,\n  labelToFieldName,\n  ensureUniqueFieldName,\n} from \"./schema-generator\";\n\n// Hook for custom implementations\nexport { useFormBuilder } from \"./use-form-builder\";\n\n// Constants\nexport { FIELD_TYPES, getFieldTypeConfig } from \"./constants\";\nexport type { FieldTypeConfig } from \"./constants\";\n\n// Sub-components for composition\nexport { FieldCard } from \"./field-card\";\nexport type { FieldCardProps } from \"./field-card\";\nexport { FieldTypeSelector } from \"./field-type-selector\";\nexport type { FieldTypeSelectorProps } from \"./field-type-selector\";\nexport { FieldOptions } from \"./field-options\";\nexport type { FieldOptionsProps } from \"./field-options\";\nexport { EnumValuesEditor } from \"./enum-values-editor\";\nexport type { EnumValuesEditorProps } from \"./enum-values-editor\";\n\n// Form metadata (forms-fragment specific, can be removed if not using @fragno-dev/forms)\nexport { FormMetadataEditor } from \"./form-metadata\";\nexport type { FormMetadataEditorProps, FormMetadata, FormStatus } from \"./form-metadata\";\n"
    }
  ]
}
